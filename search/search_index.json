{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Signature Core Nodes Documentation","text":"<p>A powerful collection of custom nodes for ComfyUI that provides essential image processing, data handling, and workflow management capabilities.</p> <p>\ud83d\udcda View Full Documentation</p>"},{"location":"#features","title":"\ud83c\udf1f Features","text":"<ul> <li> <p>Image Processing</p> </li> <li> <p>Advanced image transformations and filters</p> </li> <li>Color manipulation and blending modes</li> <li>Mask generation and operations</li> <li> <p>Background removal and image composition</p> </li> <li> <p>Data Handling</p> </li> <li> <p>JSON/Dictionary conversions</p> </li> <li>File operations</li> <li>Platform I/O management</li> <li> <p>Primitive type handling</p> </li> <li> <p>Workflow Management</p> </li> <li> <p>Custom workflow wrapper</p> </li> <li>Platform integration</li> <li>Progress tracking</li> <li> <p>Error handling</p> </li> <li> <p>Augmentations</p> </li> <li>Random crop</li> <li>Image flipping</li> <li>Composite augmentations</li> <li>Batch processing</li> </ul>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<ol> <li>Clone this repository into your ComfyUI custom nodes directory:</li> </ol> <pre><code>git clone https://github.com/yourusername/signature-core-nodes.git ComfyUI/custom_nodes/signature-core-nodes\n</code></pre> <ol> <li>Install the required dependencies:</li> </ol> <pre><code>cd ComfyUI/custom_nodes/signature-core-nodes\npip install -e .\n</code></pre>"},{"location":"#node-categories","title":"\ud83d\udce6 Node Categories","text":"<ul> <li>\ud83d\uddbc\ufe0f Image - Image processing and manipulation nodes</li> <li>\ud83c\udfad Mask - Mask generation and operations</li> <li>\ud83d\udd24 Text - Text processing and manipulation nodes</li> <li>\ud83d\udd22 Numbers - Numerical operations and processing</li> <li>\ud83d\udd04 Transform - Image transformation tools</li> <li>\ud83e\uddf1 Primitives - Basic data type nodes</li> <li>\ud83e\udd16 Models - AI model integration nodes</li> <li>\ud83e\udde0 Logic - Logic operations and control flow</li> <li>\ud83d\udcc1 File - File handling operations</li> <li>\ud83d\udd00 Augmentation - Image augmentation tools</li> <li>\ud83d\udd0c Platform I/O - Platform integration nodes</li> <li>\ud83d\udcca Data - Data conversion and handling</li> <li>\ud83e\uddec Loras - LoRA model handling and integration</li> <li>\ud83d\udee0\ufe0f Utils - Utility functions</li> </ul>"},{"location":"#usage","title":"\ud83d\udcbb Usage","text":"<p>After installation, the Signature Core nodes will be available in your ComfyUI workspace under the \"\ud83d\udd32 Signature Nodes\" category. Each node is designed to be intuitive and includes proper input validation and error handling.</p>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Load an image using <code>ImageFromWeb</code> or <code>ImageFromBase64</code></li> <li>Apply transformations using nodes like <code>ImageTranspose</code> or <code>UpscaleImage</code></li> <li>Process the image using various filter nodes</li> <li>Export the result using <code>PlatformOutput</code> or save directly</li> </ol>"},{"location":"#development","title":"\ud83d\udee0 Development","text":"<p>The project is structured with clear separation of concerns:</p> <ul> <li><code>nodes/</code> - Contains all node implementations</li> <li><code>web/</code> - Web interface components and extensions</li> <li><code>categories.py</code> - Node category definitions</li> <li><code>shared.py</code> - Shared utilities and constants</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"nodes/augmentations/","title":"Augmentations Nodes","text":""},{"location":"nodes/augmentations/#randomcropaugmentation","title":"RandomCropAugmentation","text":"<p>Applies a random crop augmentation to an image</p>"},{"location":"nodes/augmentations/#inputs","title":"Inputs","text":"Group Name Type Default Extras required height INT 1024 min: 32, step: 32 required width INT 1024 min: 32, step: 32 required min_window INT 256 step: 32 required max_window INT 1024 step: 32 required percent FLOAT 1.0 min: 0.0, max: 1.0 optional augmentation AUGMENTATION None"},{"location":"nodes/augmentations/#returns","title":"Returns","text":"Name Type augmentation <code>AUGMENTATION</code> Pick the code in augmentations.py <pre><code>class RandomCropAugmentation:\n    \"\"\"Applies a random crop augmentation to an image.\n\n    This class performs a random crop on an image based on specified dimensions and percentage.\n\n    Methods:\n        execute(**kwargs): Applies the random crop augmentation and returns the augmented image.\n\n    Args:\n        height (int): The height of the image.\n        width (int): The width of the image.\n        min_window (int): The minimum window size for cropping.\n        max_window (int): The maximum window size for cropping.\n        percent (float): The percentage of the image to crop.\n        augmentation: An optional existing augmentation to apply.\n\n    Returns:\n        tuple: The augmented image.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"height\": (\"INT\", {\"default\": 1024, \"min\": 32, \"step\": 32}),\n                \"width\": (\"INT\", {\"default\": 1024, \"min\": 32, \"step\": 32}),\n                \"min_window\": (\"INT\", {\"default\": 256, \"step\": 32}),\n                \"max_window\": (\"INT\", {\"default\": 1024, \"step\": 32}),\n                \"percent\": (\"FLOAT\", {\"default\": 1.0, \"min\": 0.0, \"max\": 1.0}),\n            },\n            \"optional\": {\n                \"augmentation\": (\"AUGMENTATION\", {\"default\": None}),\n            },\n        }\n\n    RETURN_TYPES = (\"AUGMENTATION\",)\n    RETURN_NAMES = (\"augmentation\",)\n    FUNCTION = \"execute\"\n    CATEGORY = AUGMENTATION_CAT\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        height = kwargs.get(\"height\") or 1024\n        width = kwargs.get(\"width\") or 1024\n        min_window = kwargs.get(\"min_window\") or 256\n        max_window = kwargs.get(\"max_window\") or 1024\n        percent = kwargs.get(\"percent\") or 1.0\n        augmentation = kwargs.get(\"augmentation\")\n        augmentation = random_crop_augmentation(height, width, min_window, max_window, percent, augmentation)\n        return (augmentation,)\n</code></pre>"},{"location":"nodes/augmentations/#flipaugmentation","title":"FlipAugmentation","text":"<p>Applies a flip augmentation to an image</p>"},{"location":"nodes/augmentations/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required flip horizontal required percent FLOAT 0.5 min: 0.0, max: 1.0 optional augmentation AUGMENTATION None"},{"location":"nodes/augmentations/#returns_1","title":"Returns","text":"Name Type augmentation <code>AUGMENTATION</code> Pick the code in augmentations.py <pre><code>class FlipAugmentation:\n    \"\"\"Applies a flip augmentation to an image.\n\n    This class performs a horizontal or vertical flip on an image based on the specified direction and percentage.\n\n    Methods:\n        execute(**kwargs): Applies the flip augmentation and returns the augmented image.\n\n    Args:\n        flip (str): The direction of the flip ('horizontal' or 'vertical').\n        percent (float): The percentage of the image to flip.\n        augmentation: An optional existing augmentation to apply.\n\n    Returns:\n        tuple: The augmented image.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"flip\": ([\"horizontal\", \"vertical\"], {\"default\": \"horizontal\"}),\n                \"percent\": (\"FLOAT\", {\"default\": 0.5, \"min\": 0.0, \"max\": 1.0}),\n            },\n            \"optional\": {\n                \"augmentation\": (\"AUGMENTATION\", {\"default\": None}),\n            },\n        }\n\n    RETURN_TYPES = (\"AUGMENTATION\",)\n    RETURN_NAMES = (\"augmentation\",)\n    FUNCTION = \"execute\"\n    CATEGORY = AUGMENTATION_CAT\n\n    def execute(self, **kwargs):\n        flip = kwargs.get(\"flip\") or \"horizontal\"\n        percent = kwargs.get(\"percent\") or 0.5\n        augmentation = kwargs.get(\"augmentation\")\n        augmentation = flip_augmentation(flip, percent, augmentation)\n        return (augmentation,)\n</code></pre>"},{"location":"nodes/augmentations/#composeaugmentation","title":"ComposeAugmentation","text":"<p>Composes multiple augmentations and applies them to an image and mask</p>"},{"location":"nodes/augmentations/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required augmentation AUGMENTATION required samples INT 1 min: 1 required seed INT max: 10000000000000000 optional image IMAGE None optional mask MASK None"},{"location":"nodes/augmentations/#returns_2","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> Pick the code in augmentations.py <pre><code>class ComposeAugmentation:\n    \"\"\"Composes multiple augmentations and applies them to an image and mask.\n\n    This class combines multiple augmentations and applies them to an image and mask,\n    supporting multiple samples and random seeds.\n\n    Methods:\n        execute(**kwargs): Applies the composed augmentations and returns the augmented images and masks.\n\n    Args:\n        augmentation: The augmentation to apply.\n        samples (int): The number of samples to generate.\n        seed (int): The random seed for augmentation.\n        image: The input image to augment.\n        mask: The input mask to augment.\n\n    Returns:\n        tuple: Lists of augmented images and masks.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"augmentation\": (\"AUGMENTATION\",),\n                \"samples\": (\"INT\", {\"default\": 1, \"min\": 1}),\n                \"seed\": (\"INT\", {\"default\": -1, \"min\": -1, \"max\": 10000000000000000}),\n            },\n            \"optional\": {\n                \"image\": (\"IMAGE\", {\"default\": None}),\n                \"mask\": (\"MASK\", {\"default\": None}),\n            },\n        }\n\n    RETURN_TYPES = (\n        \"IMAGE\",\n        \"MASK\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = AUGMENTATION_CAT\n    OUTPUT_IS_LIST = (\n        True,\n        True,\n    )\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        augmentation = kwargs.get(\"augmentation\")\n        samples = kwargs.get(\"samples\") or 1\n        image = kwargs.get(\"image\")\n        mask = kwargs.get(\"mask\")\n        seed = kwargs.get(\"seed\") or -1\n\n        image_tensor = TensorImage.from_BWHC(image) if isinstance(image, torch.Tensor) else None\n        mask_tensor = TensorImage.from_BWHC(mask) if isinstance(mask, torch.Tensor) else None\n\n        total_images, total_masks = compose_augmentation(\n            augmentation=augmentation,\n            samples=samples,\n            image_tensor=image_tensor,\n            mask_tensor=mask_tensor,\n            seed=seed,\n        )\n\n        if total_images is None:\n            total_images = []\n        if total_masks is None:\n            total_masks = []\n        node_image = [image.get_BWHC() for image in total_images]\n        node_mask = [mask.get_BWHC() for mask in total_masks]\n        return (\n            node_image,\n            node_mask,\n        )\n</code></pre>"},{"location":"nodes/data/","title":"Data Nodes","text":""},{"location":"nodes/data/#jsontodict","title":"JsonToDict","text":"<p>Converts a JSON string to a Python dictionary</p>"},{"location":"nodes/data/#inputs","title":"Inputs","text":"Group Name Type Default Extras required json_str STRING forceInput: True"},{"location":"nodes/data/#returns","title":"Returns","text":"Name Type dict <code>DICT</code> Pick the code in data.py <pre><code>class JsonToDict:\n    \"\"\"Converts a JSON string to a Python dictionary.\n\n    This class parses a JSON-formatted string and converts it into a Python dictionary.\n\n    Methods:\n        execute(**kwargs): Parses the JSON string and returns the resulting dictionary.\n\n    Args:\n        json_str (str): The JSON string to be converted.\n\n    Returns:\n        tuple: A tuple containing the resulting dictionary.\n\n    Raises:\n        ValueError: If the input is not a string.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"json_str\": (\"STRING\", {\"default\": \"\", \"forceInput\": True}),\n            },\n        }\n\n    RETURN_TYPES = (\"DICT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = DATA_CAT\n\n    def execute(self, **kwargs):\n        json_str = kwargs.get(\"json_str\")\n        if not isinstance(json_str, str):\n            raise ValueError(\"Json string must be a string\")\n        json_dict = json.loads(json_str)\n        return (json_dict,)\n</code></pre>"},{"location":"nodes/data/#dicttojson","title":"DictToJson","text":"<p>Converts a Python dictionary to a JSON string</p>"},{"location":"nodes/data/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required dict DICT"},{"location":"nodes/data/#returns_1","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in data.py <pre><code>class DictToJson:\n    \"\"\"Converts a Python dictionary to a JSON string.\n\n    This class serializes a Python dictionary into a JSON-formatted string.\n\n    Methods:\n        execute(**kwargs): Serializes the dictionary and returns the resulting JSON string.\n\n    Args:\n        dict (dict): The dictionary to be converted.\n\n    Returns:\n        tuple: A tuple containing the resulting JSON string.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"dict\": (\"DICT\",),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = DATA_CAT\n\n    def execute(self, **kwargs):\n        json_dict = kwargs.get(\"dict\")\n        json_str = json.dumps(json_dict)\n        return (json_str,)\n</code></pre>"},{"location":"nodes/data/#getimagelistitem","title":"GetImageListItem","text":"<p>Retrieves an image from a list by index</p>"},{"location":"nodes/data/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required images IMAGE required index INT 0"},{"location":"nodes/data/#returns_2","title":"Returns","text":"Name Type i <code>I</code> m <code>M</code> a <code>A</code> g <code>G</code> e <code>E</code> Pick the code in data.py <pre><code>class GetImageListItem:\n    \"\"\"Retrieves an image from a list by index.\n\n    This class accesses a list of images and retrieves the image at the specified index.\n\n    Methods:\n        execute(**kwargs): Returns the image at the specified index.\n\n    Args:\n        images (list): The list of images.\n        index (int): The index of the image to retrieve.\n\n    Returns:\n        tuple: A tuple containing the retrieved image.\n\n    Raises:\n        ValueError: If the index is not an integer or if images is not a list.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"images\": (\"IMAGE\",),\n                \"index\": (\"INT\", {\"default\": 0}),\n            },\n        }\n\n    RETURN_TYPES = \"IMAGE\"\n    RETURN_NAMES = \"image\"\n    FUNCTION = \"execute\"\n    CATEGORY = DATA_CAT\n\n    def execute(self, **kwargs):\n        images = kwargs.get(\"images\")\n        index = kwargs.get(\"index\")\n        if not isinstance(index, int):\n            raise ValueError(\"Index must be an integer\")\n        if not isinstance(images, list):\n            raise ValueError(\"Images must be a list\")\n        images = images[index]\n        index = kwargs.get(\"index\")\n        image = images[index]\n        return (image,)\n</code></pre>"},{"location":"nodes/data/#getlistitem","title":"GetListItem","text":"<p>Retrieves an item from a list by index and returns its type</p>"},{"location":"nodes/data/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required list LIST required index INT 0 Pick the code in data.py <pre><code>class GetListItem:\n    \"\"\"Retrieves an item from a list by index and returns its type.\n\n    This class accesses a list and retrieves the item at the specified index, also returning the item's type.\n\n    Methods:\n        execute(**kwargs): Returns the item and its type.\n\n    Args:\n        list (list): The list to access.\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        tuple: A tuple containing the item and its type as a string.\n\n    Raises:\n        ValueError: If the index is not an integer or if the list is not a list.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"list\": (\"LIST\",),\n                \"index\": (\"INT\", {\"default\": 0}),\n            },\n        }\n\n    RETURN_TYPES = (any_type, \"STRING\")\n    RETURN_NAMES = (\"item\", \"value_type\")\n    FUNCTION = \"execute\"\n    CATEGORY = DATA_CAT\n\n    def execute(self, **kwargs):\n        list_obj = kwargs.get(\"list\")\n        index = kwargs.get(\"index\")\n        if not isinstance(index, int):\n            raise ValueError(\"Index must be an integer\")\n        if not isinstance(list_obj, list):\n            raise ValueError(\"Input must be a list\")\n        item = list_obj[index]\n        item_type = type(item).__name__\n        return (item, item_type)\n</code></pre>"},{"location":"nodes/data/#getdictvalue","title":"GetDictValue","text":"<p>Retrieves a value from a dictionary by key and returns its type</p>"},{"location":"nodes/data/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required dict DICT required key STRING Pick the code in data.py <pre><code>class GetDictValue:\n    \"\"\"Retrieves a value from a dictionary by key and returns its type.\n\n    This class accesses a dictionary and retrieves the value\n    associated with the specified key, also returning the value's type.\n\n    Methods:\n        execute(**kwargs): Returns the value and its type.\n\n    Args:\n        dict (dict): The dictionary to access.\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        tuple: A tuple containing the value and its type as a string.\n\n    Raises:\n        ValueError: If the key is not a string or if the dict is not a dictionary.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"dict\": (\"DICT\",),\n                \"key\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (any_type, \"STRING\")\n    RETURN_NAMES = (\"value\", \"value_type\")\n    FUNCTION = \"execute\"\n    CATEGORY = DATA_CAT\n\n    def execute(self, **kwargs):\n        dict_obj = kwargs.get(\"dict\")\n        key = kwargs.get(\"key\")\n        if not isinstance(key, str):\n            raise ValueError(\"Key must be a string\")\n        if not isinstance(dict_obj, dict):\n            raise ValueError(\"Dict must be a dictionary\")\n        value = dict_obj.get(key)\n        value_type = type(value).__name__\n        return (value, value_type)\n</code></pre>"},{"location":"nodes/file/","title":"File Nodes","text":""},{"location":"nodes/file/#imagefromweb","title":"ImageFromWeb","text":"<p>Loads an image from a URL</p>"},{"location":"nodes/file/#inputs","title":"Inputs","text":"Group Name Type Default Extras required url STRING URL HERE"},{"location":"nodes/file/#returns","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> Pick the code in file.py <pre><code>class ImageFromWeb:\n    \"\"\"Loads an image from a URL.\n\n    Parameters:\n        url (str): URL of the image to load\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Image tensor in BWHC format and mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\"required\": {\"url\": (\"STRING\", {\"default\": \"URL HERE\"})}}\n\n    RETURN_TYPES = (\"IMAGE\", \"MASK\")\n    FUNCTION = \"execute\"\n    CATEGORY = FILE_CAT\n\n    def execute(self, **kwargs):\n        url = kwargs.get(\"url\")\n        if not isinstance(url, str):\n            raise ValueError(\"URL must be a string\")\n        img_arr = TensorImage.from_web(url)\n        return image_array_to_tensor(img_arr)\n</code></pre>"},{"location":"nodes/file/#imagefrombase64","title":"ImageFromBase64","text":"<p>Converts a base64 string to an image</p>"},{"location":"nodes/file/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required base64 STRING BASE64 HERE"},{"location":"nodes/file/#returns_1","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> Pick the code in file.py <pre><code>class ImageFromBase64:\n    \"\"\"Converts a base64 string to an image.\n\n    Parameters:\n        base64 (str): Base64-encoded image string\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Image tensor in BWHC format and mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\"required\": {\"base64\": (\"STRING\", {\"default\": \"BASE64 HERE\"})}}\n\n    RETURN_TYPES = (\"IMAGE\", \"MASK\")\n    FUNCTION = \"execute\"\n    CATEGORY = FILE_CAT\n\n    def execute(self, **kwargs):\n        base64 = kwargs.get(\"base64\")\n        if not isinstance(base64, str):\n            raise ValueError(\"Base64 must be a string\")\n        img_arr = TensorImage.from_base64(base64)\n        return image_array_to_tensor(img_arr)\n</code></pre>"},{"location":"nodes/file/#base64fromimage","title":"Base64FromImage","text":"<p>Converts an image to a base64 string</p>"},{"location":"nodes/file/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/file/#returns_2","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in file.py <pre><code>class Base64FromImage:\n    \"\"\"Converts an image to a base64 string.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n\n    Returns:\n        tuple[str]: Base64-encoded string representation of the image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\"required\": {\"image\": (\"IMAGE\",)}}\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = FILE_CAT\n    OUTPUT_NODE = True\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n        images = TensorImage.from_BWHC(image)\n        output = images.get_base64()\n        return (output,)\n</code></pre>"},{"location":"nodes/file/#fileloader","title":"FileLoader","text":"<p>Loads file data from a string value</p>"},{"location":"nodes/file/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required value STRING"},{"location":"nodes/file/#returns_3","title":"Returns","text":"Name Type file <code>FILE</code> Pick the code in file.py <pre><code>class FileLoader:\n    \"\"\"Loads file data from a string value.\n\n    Parameters:\n        value (str): Input string containing file data (JSON format)\n\n    Returns:\n        tuple[list]: List of file data with updated paths\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"FILE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = FILE_CAT\n\n    def execute(self, **kwargs):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        data = value.split(\"&amp;&amp;\") if \"&amp;&amp;\" in value else [value]\n        input_folder = os.path.join(BASE_COMFY_DIR, \"input\")\n        for i, _ in enumerate(data):\n            json_str = data[i]\n            data[i] = json.loads(json_str)\n            item = data[i]\n            if isinstance(item, dict):\n                name = item.get(\"name\", None)\n                if name is None:\n                    continue\n                item[\"name\"] = os.path.join(input_folder, name)\n                data[i] = item\n\n        return (data,)\n</code></pre>"},{"location":"nodes/file/#folderloader","title":"FolderLoader","text":"<p>Loads file data from a folder path</p>"},{"location":"nodes/file/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required value STRING"},{"location":"nodes/file/#returns_4","title":"Returns","text":"Name Type file <code>FILE</code> Pick the code in file.py <pre><code>class FolderLoader:\n    \"\"\"Loads file data from a folder path.\n\n    Parameters:\n        value (str): Input string containing folder path data\n\n    Returns:\n        tuple[list]: List of file data with updated paths from the folder\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"FILE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = FILE_CAT\n\n    def execute(self, **kwargs):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        data = value.split(\"&amp;&amp;\") if \"&amp;&amp;\" in value else [value]\n        input_folder = os.path.join(BASE_COMFY_DIR, \"input\")\n        for i, _ in enumerate(data):\n            json_str = data[i]\n            data[i] = json.loads(json_str)\n            item = data[i]\n            if isinstance(item, dict):\n                name = item.get(\"name\", None)\n                if name is None:\n                    continue\n                item[\"name\"] = os.path.join(input_folder, name)\n                data[i] = item\n        return (data,)\n</code></pre>"},{"location":"nodes/file/#rotate","title":"Rotate","text":"<p>Rotates an image and mask by a specified angle</p> Pick the code in file.py <pre><code>class Rotate:\n    \"\"\"Rotates an image and mask by a specified angle.\n\n    Parameters:\n        image (torch.Tensor, optional): Input image in BWHC format\n        mask (torch.Tensor, optional): Input mask in BWHC format\n        angle (float): Rotation angle in degrees (0-360)\n        zoom_to_fit (bool): Whether to zoom to fit rotated content (default: False)\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Rotated image and mask\n    \"\"\"\n</code></pre>"},{"location":"nodes/file/#maskgaussianblur","title":"MaskGaussianBlur","text":"<p>Applies Gaussian blur to a mask</p> Pick the code in file.py <pre><code>class MaskGaussianBlur:\n    \"\"\"Applies Gaussian blur to a mask.\n\n    Parameters:\n        image (torch.Tensor): Input mask in BWHC format\n        radius (int): Blur radius (default: 13)\n        sigma (float): Blur sigma/strength (default: 10.5)\n        iterations (int): Number of blur passes (default: 1)\n        only_outline (bool): Whether to blur only the outline (default: False)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the blurred mask\n    \"\"\"\n</code></pre>"},{"location":"nodes/image/","title":"Image Nodes","text":""},{"location":"nodes/image/#imagebasecolor","title":"ImageBaseColor","text":"<p>Creates a solid color image of specified dimensions</p>"},{"location":"nodes/image/#inputs","title":"Inputs","text":"Group Name Type Default Extras required hex_color STRING #FFFFFF required width INT 1024 required height INT 1024"},{"location":"nodes/image/#returns","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageBaseColor:\n    \"\"\"Creates a solid color image of specified dimensions.\n\n    Parameters:\n        hex_color (str): Hex color code (e.g., \"#FFFFFF\")\n        width (int): Width of the output image\n        height (int): Height of the output image\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing a BWHC format tensor\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"hex_color\": (\"STRING\", {\"default\": \"#FFFFFF\"}),\n                \"width\": (\"INT\", {\"default\": 1024}),\n                \"height\": (\"INT\", {\"default\": 1024}),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        hex_color = kwargs.get(\"hex_color\")\n        width = kwargs.get(\"width\")\n        height = kwargs.get(\"height\")\n        if not isinstance(width, int):\n            raise ValueError(\"Width must be an integer\")\n        if not isinstance(height, int):\n            raise ValueError(\"Height must be an integer\")\n        if not isinstance(hex_color, str):\n            raise ValueError(\"Hex color must be a string\")\n        hex_color = hex_color.lstrip(\"#\")\n        r, g, b = tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))\n\n        # Create a tensor with the specified color\n        color_tensor = torch.tensor([r, g, b], dtype=torch.float32) / 255.0\n\n        # Reshape to (3, 1, 1) and expand to (3, H, W)\n        color_tensor = color_tensor.view(3, 1, 1).expand(3, height, width)\n\n        # Repeat for the batch size\n        batch_tensor = color_tensor.unsqueeze(0).expand(1, -1, -1, -1)\n\n        output = TensorImage(batch_tensor).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imagegaussianblur","title":"ImageGaussianBlur","text":"<p>Applies Gaussian blur to an input image</p>"},{"location":"nodes/image/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required radius INT 13 required sigma FLOAT 10.5 required interations INT 1"},{"location":"nodes/image/#returns_1","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageGaussianBlur:\n    \"\"\"Applies Gaussian blur to an input image.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        radius (int): Blur radius (default: 13)\n        sigma (float): Blur sigma/strength (default: 10.5)\n        interations (int): Number of blur passes (default: 1)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the blurred image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"radius\": (\"INT\", {\"default\": 13}),\n                \"sigma\": (\"FLOAT\", {\"default\": 10.5}),\n                \"interations\": (\"INT\", {\"default\": 1}),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n        radius = kwargs.get(\"radius\")\n        if not isinstance(radius, int):\n            raise ValueError(\"Radius must be an integer\")\n        sigma = kwargs.get(\"sigma\")\n        if not isinstance(sigma, float):\n            raise ValueError(\"Sigma must be a float\")\n        interations = kwargs.get(\"interations\")\n        if not isinstance(interations, int):\n            raise ValueError(\"Interations must be an integer\")\n        tensor_image = TensorImage.from_BWHC(image)\n        output = gaussian_blur2d(tensor_image, radius, sigma, interations).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imageunsharpmask","title":"ImageUnsharpMask","text":"<p>Applies unsharp mask filter to sharpen an image</p>"},{"location":"nodes/image/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required radius INT 3 required sigma FLOAT 1.5 required interations INT 1"},{"location":"nodes/image/#returns_2","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageUnsharpMask:\n    \"\"\"Applies unsharp mask filter to sharpen an image.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        radius (int): Sharpening radius (default: 3)\n        sigma (float): Sharpening strength (default: 1.5)\n        interations (int): Number of sharpening passes (default: 1)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the sharpened image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"radius\": (\"INT\", {\"default\": 3}),\n                \"sigma\": (\"FLOAT\", {\"default\": 1.5}),\n                \"interations\": (\"INT\", {\"default\": 1}),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n        radius = kwargs.get(\"radius\")\n        if not isinstance(radius, int):\n            raise ValueError(\"Radius must be an integer\")\n        sigma = kwargs.get(\"sigma\")\n        if not isinstance(sigma, float):\n            raise ValueError(\"Sigma must be a float\")\n        interations = kwargs.get(\"interations\")\n        if not isinstance(interations, int):\n            raise ValueError(\"Interations must be an integer\")\n        tensor_image = TensorImage.from_BWHC(image)\n        output = unsharp_mask(tensor_image, radius, sigma, interations).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imagesoftlight","title":"ImageSoftLight","text":"<p>Applies soft light blend mode between two images</p>"},{"location":"nodes/image/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required top IMAGE required bottom IMAGE"},{"location":"nodes/image/#returns_3","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageSoftLight:\n    \"\"\"Applies soft light blend mode between two images.\n\n    Parameters:\n        top (torch.Tensor): Top layer image in BWHC format\n        bottom (torch.Tensor): Bottom layer image in BWHC format\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the blended image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"top\": (\"IMAGE\",),\n                \"bottom\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        top = kwargs.get(\"top\")\n        bottom = kwargs.get(\"bottom\")\n        if not isinstance(top, torch.Tensor):\n            raise ValueError(\"Top must be a torch.Tensor\")\n        if not isinstance(bottom, torch.Tensor):\n            raise ValueError(\"Bottom must be a torch.Tensor\")\n        top_tensor = TensorImage.from_BWHC(top)\n        bottom_tensor = TensorImage.from_BWHC(bottom)\n        output = image_soft_light(top_tensor, bottom_tensor).get_BWHC()\n\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imageaverage","title":"ImageAverage","text":"<p>Calculates the color average of an input image</p>"},{"location":"nodes/image/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/image/#returns_4","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageAverage:\n    \"\"\"Calculates the color average of an input image.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the averaged image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n        step = TensorImage.from_BWHC(image)\n        output = color_average(step).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imagesubtract","title":"ImageSubtract","text":"<p>Subtracts one image from another (absolute difference)</p>"},{"location":"nodes/image/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required image_0 IMAGE required image_1 IMAGE"},{"location":"nodes/image/#returns_5","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageSubtract:\n    \"\"\"Subtracts one image from another (absolute difference).\n\n    Parameters:\n        image_0 (torch.Tensor): First image in BWHC format\n        image_1 (torch.Tensor): Second image in BWHC format\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the difference image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image_0\": (\"IMAGE\",),\n                \"image_1\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        image_0 = kwargs.get(\"image_0\")\n        image_1 = kwargs.get(\"image_1\")\n        if not isinstance(image_0, torch.Tensor):\n            raise ValueError(\"Image 0 must be a torch.Tensor\")\n        if not isinstance(image_1, torch.Tensor):\n            raise ValueError(\"Image 1 must be a torch.Tensor\")\n        image_0_tensor = TensorImage.from_BWHC(image_0)\n        image_1_tensor = TensorImage.from_BWHC(image_1)\n        image_tensor = torch.abs(image_0_tensor - image_1_tensor)\n        output = TensorImage(image_tensor).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/image/#imagetranspose","title":"ImageTranspose","text":"<p>Transforms an overlay image onto a base image with various adjustments</p>"},{"location":"nodes/image/#inputs_6","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required image_overlay IMAGE required width INT max: 48000, step: 1 required height INT max: 48000, step: 1 required X INT 0 min: 0, max: 48000, step: 1 required Y INT 0 min: 0, max: 48000, step: 1 required rotation INT 0 max: 360, step: 1 required feathering INT 0 min: 0, max: 100, step: 1"},{"location":"nodes/image/#returns_6","title":"Returns","text":"Name Type image <code>IMAGE</code> image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageTranspose:\n    \"\"\"Transforms an overlay image onto a base image with various adjustments.\n\n    Parameters:\n        image (torch.Tensor): Base image in BWHC format\n        image_overlay (torch.Tensor): Overlay image in BWHC format\n        width (int): Target width for overlay (-1 for original size)\n        height (int): Target height for overlay (-1 for original size)\n        X (int): Horizontal offset\n        Y (int): Vertical offset\n        rotation (int): Rotation angle in degrees\n        feathering (int): Edge feathering amount\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: RGB and RGBA versions of the composited image\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"image_overlay\": (\"IMAGE\",),\n                \"width\": (\"INT\", {\"default\": -1, \"min\": -1, \"max\": 48000, \"step\": 1}),\n                \"height\": (\"INT\", {\"default\": -1, \"min\": -1, \"max\": 48000, \"step\": 1}),\n                \"X\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 48000, \"step\": 1}),\n                \"Y\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 48000, \"step\": 1}),\n                \"rotation\": (\"INT\", {\"default\": 0, \"min\": -360, \"max\": 360, \"step\": 1}),\n                \"feathering\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 100, \"step\": 1}),\n            },\n        }\n\n    RETURN_TYPES = (\n        \"IMAGE\",\n        \"IMAGE\",\n    )\n    RETURN_NAMES = (\n        \"rgb\",\n        \"rgba\",\n    )\n    FUNCTION = \"execute\"\n\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n        image_overlay = kwargs.get(\"image_overlay\")\n        if not isinstance(image_overlay, torch.Tensor):\n            raise ValueError(\"Image overlay must be a torch.Tensor\")\n        width = kwargs.get(\"width\")\n        if not isinstance(width, int):\n            raise ValueError(\"Width must be an integer\")\n        height = kwargs.get(\"height\")\n        if not isinstance(height, int):\n            raise ValueError(\"Height must be an integer\")\n        x = kwargs.get(\"X\")\n        if not isinstance(x, int):\n            raise ValueError(\"X must be an integer\")\n        y = kwargs.get(\"Y\")\n        if not isinstance(y, int):\n            raise ValueError(\"Y must be an integer\")\n        rotation = kwargs.get(\"rotation\")\n        if not isinstance(rotation, int):\n            raise ValueError(\"Rotation must be an integer\")\n        feathering = kwargs.get(\"feathering\")\n        if not isinstance(feathering, int):\n            raise ValueError(\"Feathering must be an integer\")\n\n        base_image = TensorImage.from_BWHC(image)\n        overlay_image = TensorImage.from_BWHC(image_overlay)\n\n        if width == -1:\n            width = overlay_image.shape[3]\n        if height == -1:\n            height = overlay_image.shape[2]\n\n        device = base_image.device\n        overlay_image = overlay_image.to(device)\n\n        # Resize overlay image\n        overlay_image = transform.resize(overlay_image, (height, width))\n\n        if rotation != 0:\n            angle = torch.tensor(rotation, dtype=torch.float32, device=device)\n            center = torch.tensor([width / 2, height / 2], dtype=torch.float32, device=device)\n            overlay_image = transform.rotate(overlay_image, angle, center=center)\n\n        # Create mask (handle both RGB and RGBA cases)\n        if overlay_image.shape[1] == 4:\n            mask = overlay_image[:, 3:4, :, :]\n        else:\n            mask = torch.ones((1, 1, height, width), device=device)\n\n        # Pad overlay image and mask\n        pad_left = x\n        pad_top = y\n        pad_right = max(0, base_image.shape[3] - overlay_image.shape[3] - x)\n        pad_bottom = max(0, base_image.shape[2] - overlay_image.shape[2] - y)\n\n        overlay_image = torch.nn.functional.pad(overlay_image, (pad_left, pad_right, pad_top, pad_bottom))\n        mask = torch.nn.functional.pad(mask, (pad_left, pad_right, pad_top, pad_bottom))\n\n        # Resize to match base image\n        overlay_image = transform.resize(overlay_image, base_image.shape[2:])\n        mask = transform.resize(mask, base_image.shape[2:])\n\n        if feathering &gt; 0:\n            kernel_size = 2 * feathering + 1\n            feather_kernel = torch.ones((1, 1, kernel_size, kernel_size), device=device) / (kernel_size**2)\n            mask = torch.nn.functional.conv2d(mask, feather_kernel, padding=feathering)\n\n        # Blend images\n        result = base_image * (1 - mask) + overlay_image[:, :3, :, :] * mask\n\n        result = TensorImage(result).get_BWHC()\n\n        rgb = result\n        rgba = torch.cat([rgb, mask.permute(0, 2, 3, 1)], dim=3)\n\n        return (rgb, rgba)\n</code></pre>"},{"location":"nodes/image/#imagelist2batch","title":"ImageList2Batch","text":"<p>Converts a list of images into a batched tensor, handling different image sizes</p>"},{"location":"nodes/image/#inputs_7","title":"Inputs","text":"Group Name Type Default Extras required images IMAGE required mode required interpolation"},{"location":"nodes/image/#returns_7","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageList2Batch:\n    \"\"\"Converts a list of images into a batched tensor, handling different image sizes.\n\n    Parameters:\n        images (list[torch.Tensor]): List of input images\n        mode (str): Resize mode ('STRETCH', 'FIT', 'FILL', 'ASPECT')\n        interpolation (str): Interpolation method for resizing\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the batched images\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"images\": (\"IMAGE\",),\n                \"mode\": ([\"STRETCH\", \"FIT\", \"FILL\", \"ASPECT\"],),\n                \"interpolation\": ([\"bilinear\", \"nearest\", \"bicubic\", \"area\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n    INPUT_IS_LIST = True\n\n    def execute(self, **kwargs):\n        images = kwargs.get(\"images\")\n        mode = kwargs.get(\"mode\") or \"FIT\"\n        interpolation = kwargs.get(\"interpolation\") or \"bilinear\"\n        if not isinstance(images, list):\n            raise ValueError(\"Images must be a list\")\n        if isinstance(mode, list) and len(mode) == 1:\n            mode = mode[0]\n        if isinstance(interpolation, list) and len(interpolation) == 1:\n            interpolation = interpolation[0]\n\n        if not isinstance(mode, str):\n            raise ValueError(\"Mode must be a string\")\n        if not isinstance(interpolation, str):\n            raise ValueError(\"Interpolation must be a string\")\n\n        # Check if all images have the same shape\n        shapes = [img.shape for img in images]\n        if len(set(shapes)) == 1:\n            # All images have the same shape, no need to resize\n            return (torch.stack(images),)\n\n        # Images have different shapes, proceed with resizing\n        max_height = max(img.shape[1] for img in images)\n        max_width = max(img.shape[2] for img in images)\n\n        resized_images = []\n        for img in images:\n            tensor_img = TensorImage.from_BWHC(img)\n            resized_img = resize(tensor_img, max_width, max_height, mode=mode, interpolation=interpolation)\n            resized_images.append(resized_img.get_BWHC().squeeze(0))\n\n        return (torch.stack(resized_images),)\n</code></pre>"},{"location":"nodes/image/#imagebatch2list","title":"ImageBatch2List","text":"<p>Converts a batched tensor of images into a list of individual images</p>"},{"location":"nodes/image/#inputs_8","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/image/#returns_8","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in image.py <pre><code>class ImageBatch2List:\n    \"\"\"Converts a batched tensor of images into a list of individual images.\n\n    Parameters:\n        image (torch.Tensor): Batched input images in BWHC format\n\n    Returns:\n        tuple[list[torch.Tensor]]: Single-element tuple containing list of images\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\"required\": {\"image\": (\"IMAGE\",)}}\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n    OUTPUT_IS_LIST = (True,)\n\n    def execute(self, **kwargs):\n        image = kwargs.get(\"image\")\n        if not isinstance(image, torch.Tensor):\n            raise ValueError(\"Image must be a torch.Tensor\")\n\n        image_list = [img.unsqueeze(0) for img in image]\n        return (image_list,)\n</code></pre>"},{"location":"nodes/image/#getimageshape","title":"GetImageShape","text":"<p>Returns the dimensions of an input image</p>"},{"location":"nodes/image/#inputs_9","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/image/#returns_9","title":"Returns","text":"Name Type int <code>INT</code> int <code>INT</code> int <code>INT</code> int <code>INT</code> string <code>STRING</code> Pick the code in image.py <pre><code>class GetImageShape:\n    \"\"\"Returns the dimensions of an input image.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n\n    Returns:\n        tuple[int, int, int, int, str]: Batch size, width, height, channels, and shape string\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n            },\n        }\n\n    RETURN_TYPES = (\"INT\", \"INT\", \"INT\", \"INT\", \"STRING\")\n    RETURN_NAMES = (\"batch\", \"width\", \"height\", \"channels\", \"debug\")\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_CAT\n\n    def execute(self, image):\n        return (image.shape[0], image.shape[2], image.shape[1], image.shape[3], str(image.shape))\n</code></pre>"},{"location":"nodes/image_processing/","title":"Image Processing Nodes","text":""},{"location":"nodes/image_processing/#autocrop","title":"AutoCrop","text":"<p>Automatically crops an image based on a mask</p>"},{"location":"nodes/image_processing/#inputs","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required mask MASK required mask_threshold FLOAT 0.1 min: 0.0, max: 1.0, step: 0.01 required left_padding INT 0 required right_padding INT 0 required top_padding INT 0 required bottom_padding INT 0"},{"location":"nodes/image_processing/#returns","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> int <code>INT</code> int <code>INT</code> int <code>INT</code> int <code>INT</code> Pick the code in image_processing.py <pre><code>class AutoCrop:\n    \"\"\"Automatically crops an image based on a mask.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        mask (torch.Tensor): Input mask in BWHC format\n        mask_threshold (float): Threshold for mask detection (0.0-1.0)\n        left_padding (int): Additional padding on left side\n        right_padding (int): Additional padding on right side\n        top_padding (int): Additional padding on top\n        bottom_padding (int): Additional padding on bottom\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor, int, int, int, int]:\n            - Cropped image\n            - Cropped mask\n            - X coordinate of crop\n            - Y coordinate of crop\n            - Width of crop\n            - Height of crop\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"mask\": (\"MASK\",),\n                \"mask_threshold\": (\"FLOAT\", {\"default\": 0.1, \"min\": 0.00, \"max\": 1.00, \"step\": 0.01}),\n                \"left_padding\": (\"INT\", {\"default\": 0}),\n                \"right_padding\": (\"INT\", {\"default\": 0}),\n                \"top_padding\": (\"INT\", {\"default\": 0}),\n                \"bottom_padding\": (\"INT\", {\"default\": 0}),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\", \"MASK\", \"INT\", \"INT\", \"INT\", \"INT\")\n    RETURN_NAMES = (\"cropped_image\", \"cropped_mask\", \"x\", \"y\", \"width\", \"height\")\n\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_PROCESSING_CAT\n\n    def execute(\n        self,\n        image: torch.Tensor,\n        mask: torch.Tensor,\n        mask_threshold: float,\n        left_padding: int,\n        right_padding: int,\n        top_padding: int,\n        bottom_padding: int,\n    ):\n        img_tensor = TensorImage.from_BWHC(image)\n        mask_tensor = TensorImage.from_BWHC(mask)\n        if img_tensor.shape[1] != 3:\n            img_tensor = rgba_to_rgb(img_tensor)\n\n        padding = (left_padding, right_padding, top_padding, bottom_padding)\n        img_result, mask_result, min_x, min_y, width, height = auto_crop(\n            img_tensor, mask_tensor, mask_threshold=mask_threshold, padding=padding\n        )\n        output_img = TensorImage(img_result).get_BWHC()\n        output_mask = TensorImage(mask_result).get_BWHC()\n\n        return (output_img, output_mask, min_x, min_y, width, height)\n</code></pre>"},{"location":"nodes/image_processing/#rescale","title":"Rescale","text":"<p>Rescales an image and mask by a given factor</p>"},{"location":"nodes/image_processing/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras optional image IMAGE None optional mask MASK None optional factor FLOAT 2.0 min: 0.01, max: 100.0, step: 0.01 optional interpolation optional antialias BOOLEAN True"},{"location":"nodes/image_processing/#returns_1","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> Pick the code in image_processing.py <pre><code>class Rescale:\n    \"\"\"Rescales an image and mask by a given factor.\n\n    Parameters:\n        image (torch.Tensor, optional): Input image in BWHC format\n        mask (torch.Tensor, optional): Input mask in BWHC format\n        factor (float): Scale factor (default: 2.0)\n        interpolation (str): Interpolation method (default: \"nearest\")\n        antialias (bool): Whether to use antialiasing (default: True)\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Rescaled image and mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"image\": (\"IMAGE\", {\"default\": None}),\n                \"mask\": (\"MASK\", {\"default\": None}),\n                \"factor\": (\"FLOAT\", {\"default\": 2.0, \"min\": 0.01, \"max\": 100.0, \"step\": 0.01}),\n                \"interpolation\": (\n                    [\"nearest\", \"nearest-exact\", \"bilinear\", \"bicubic\", \"box\", \"hamming\", \"lanczos\"],\n                ),\n                \"antialias\": (\"BOOLEAN\", {\"default\": True}),\n            },\n        }\n\n    RETURN_TYPES = (\n        \"IMAGE\",\n        \"MASK\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_PROCESSING_CAT\n\n    def execute(\n        self,\n        image: torch.Tensor | None = None,\n        mask: torch.Tensor | None = None,\n        factor: float = 2.0,\n        interpolation: str = \"nearest\",\n        antialias: bool = True,\n    ):\n        input_image = (\n            TensorImage.from_BWHC(image)\n            if isinstance(image, torch.Tensor)\n            else TensorImage(torch.zeros((1, 3, 1, 1)))\n        )\n        input_mask = (\n            TensorImage.from_BWHC(mask)\n            if isinstance(mask, torch.Tensor)\n            else TensorImage(torch.zeros((1, 1, 1, 1)))\n        )\n        output_image = rescale(input_image, factor, interpolation, antialias).get_BWHC()\n        output_mask = rescale(input_mask, factor, interpolation, antialias).get_BWHC()\n\n        return (\n            output_image,\n            output_mask,\n        )\n</code></pre>"},{"location":"nodes/image_processing/#resize","title":"Resize","text":"<p>Resizes an image and mask to specified dimensions</p>"},{"location":"nodes/image_processing/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras optional image IMAGE None optional mask MASK None optional width INT 1024 min: 32, step: 2, max: 40960 optional height INT 1024 min: 32, step: 2, max: 40960 optional mode optional interpolation optional antialias BOOLEAN True"},{"location":"nodes/image_processing/#returns_2","title":"Returns","text":"Name Type image <code>IMAGE</code> mask <code>MASK</code> Pick the code in image_processing.py <pre><code>class Resize:\n    \"\"\"Resizes an image and mask to specified dimensions.\n\n    Parameters:\n        image (torch.Tensor, optional): Input image in BWHC format\n        mask (torch.Tensor, optional): Input mask in BWHC format\n        width (int): Target width (default: 1024)\n        height (int): Target height (default: 1024)\n        mode (str): Resize mode (\"STRETCH\", \"FIT\", \"FILL\", \"ASPECT\")\n        interpolation (str): Interpolation method (default: \"nearest\")\n        antialias (bool): Whether to use antialiasing (default: True)\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Resized image and mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"image\": (\"IMAGE\", {\"default\": None}),\n                \"mask\": (\"MASK\", {\"default\": None}),\n                \"width\": (\"INT\", {\"default\": 1024, \"min\": 32, \"step\": 2, \"max\": 40960}),\n                \"height\": (\"INT\", {\"default\": 1024, \"min\": 32, \"step\": 2, \"max\": 40960}),\n                \"mode\": ([\"STRETCH\", \"FIT\", \"FILL\", \"ASPECT\"],),\n                \"interpolation\": ([\"bilinear\", \"nearest\", \"bicubic\", \"area\"],),\n                \"antialias\": (\n                    \"BOOLEAN\",\n                    {\"default\": True},\n                ),\n            },\n        }\n\n    RETURN_TYPES = (\n        \"IMAGE\",\n        \"MASK\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_PROCESSING_CAT\n\n    def execute(\n        self,\n        image: torch.Tensor | None = None,\n        mask: torch.Tensor | None = None,\n        width: int = 1024,\n        height: int = 1024,\n        mode: str = \"default\",\n        interpolation: str = \"nearest\",\n        antialias: bool = True,\n    ):\n        input_image = (\n            TensorImage.from_BWHC(image)\n            if isinstance(image, torch.Tensor)\n            else TensorImage(torch.zeros((1, 3, width, height)))\n        )\n        input_mask = (\n            TensorImage.from_BWHC(mask)\n            if isinstance(mask, torch.Tensor)\n            else TensorImage(torch.zeros((1, 1, width, height)))\n        )\n        output_image = resize(input_image, width, height, mode, interpolation, antialias).get_BWHC()\n        output_mask = resize(input_mask, width, height, mode, interpolation, antialias).get_BWHC()\n\n        return (\n            output_image,\n            output_mask,\n        )\n</code></pre>"},{"location":"nodes/image_processing/#cutout","title":"Cutout","text":"<p>Cuts out a portion of an image based on a mask</p>"},{"location":"nodes/image_processing/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required mask MASK"},{"location":"nodes/image_processing/#returns_3","title":"Returns","text":"Name Type image <code>IMAGE</code> image <code>IMAGE</code> Pick the code in image_processing.py <pre><code>class Cutout:\n    \"\"\"Cuts out a portion of an image based on a mask.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        mask (torch.Tensor): Mask defining the cutout area\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: RGB and RGBA versions of the cutout image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"mask\": (\"MASK\",),\n            },\n        }\n\n    RETURN_TYPES = (\"IMAGE\", \"IMAGE\")\n    RETURN_NAMES = (\"rgb\", \"rgba\")\n    FUNCTION = \"execute\"\n    CATEGORY = IMAGE_PROCESSING_CAT\n\n    def execute(self, image: torch.Tensor, mask: torch.Tensor):\n        tensor_image = TensorImage.from_BWHC(image)\n        tensor_mask = TensorImage.from_BWHC(mask, image.device)\n\n        image_rgb, image_rgba = cutout(tensor_image, tensor_mask)\n\n        out_image_rgb = TensorImage(image_rgb).get_BWHC()\n        out_image_rgba = TensorImage(image_rgba).get_BWHC()\n\n        return (\n            out_image_rgb,\n            out_image_rgba,\n        )\n</code></pre>"},{"location":"nodes/logic/","title":"Logic Nodes","text":""},{"location":"nodes/logic/#logicswitch","title":"LogicSwitch","text":"<p>Switches between two values based on a boolean condition</p>"},{"location":"nodes/logic/#inputs","title":"Inputs","text":"Group Name Type Default Extras required condition BOOLEAN False forceInput: True required true required false Pick the code in logic.py <pre><code>class LogicSwitch:\n    \"\"\"Switches between two values based on a boolean condition.\n\n    This class returns one of two values depending on the boolean condition provided.\n\n    Methods:\n        execute(**kwargs): Returns the 'true' value if the condition is True, otherwise returns the 'false' value.\n\n    Args:\n        condition (bool): The condition to evaluate.\n        true: The value to return if the condition is True.\n        false: The value to return if the condition is False.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"condition\": (\"BOOLEAN\", {\"default\": False, \"forceInput\": True}),\n                \"true\": (any_type,),\n                \"false\": (any_type,),\n            }\n        }\n\n    RETURN_TYPES = (any_type,)\n    FUNCTION = \"execute\"\n    CATEGORY = LOGIC_CAT\n\n    def execute(self, **kwargs):\n        condition = kwargs.get(\"condition\") or False\n        true_val = kwargs.get(\"true\")\n        false_val = kwargs.get(\"false\")\n\n        output = true_val if condition else false_val\n        return (output,)\n</code></pre>"},{"location":"nodes/logic/#logiccompare","title":"LogicCompare","text":"<p>Compares two values using a specified operator</p>"},{"location":"nodes/logic/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required input_a required input_b required operator"},{"location":"nodes/logic/#returns","title":"Returns","text":"Name Type boolean <code>BOOLEAN</code> Pick the code in logic.py <pre><code>class LogicCompare:\n    \"\"\"Compares two values using a specified operator.\n\n    This class compares two input values using either 'equal' or 'not_equal' operators and returns a boolean result.\n\n    Methods:\n        execute(**kwargs): Returns True if the comparison is successful, otherwise False.\n\n    Args:\n        input_a: The first value to compare.\n        input_b: The second value to compare.\n        operator (str): The comparison operator ('equal' or 'not_equal').\n\n    Raises:\n        ValueError: If any input is None or if the operator is invalid.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"input_a\": (any_type,),\n                \"input_b\": (any_type,),\n                \"operator\": ([\"equal\", \"not_equal\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"BOOLEAN\",)\n    FUNCTION = \"execute\"\n    CATEGORY = LOGIC_CAT\n\n    def execute(self, **kwargs):\n        input_a = kwargs.get(\"input_a\")\n        input_b = kwargs.get(\"input_b\")\n        operator = kwargs.get(\"operator\")\n\n        if input_a is None or input_b is None or operator is None:\n            raise ValueError(\"All inputs are required\")\n\n        def safe_compare(a, b, tensor_op, primitive_op):\n            # Handle None values\n            if a is None or b is None:\n                return a is b\n\n            # If types are different, they're never equal\n            if not isinstance(a, type(b)) and not isinstance(b, type(a)):\n                return False\n\n            # Now we know both types are compatible\n            if isinstance(a, torch.Tensor):\n                if a.shape != b.shape:\n                    # Reshape tensors to 1D for comparison\n                    a = a.reshape(-1)\n                    b = b.reshape(-1)\n                    # If sizes still don't match, compare only the overlapping part\n                    min_size = min(a.size(0), b.size(0))\n                    a = a[:min_size]\n                    b = b[:min_size]\n                return tensor_op(a, b)\n\n            return primitive_op(a, b)\n\n        operator_map = {\n            \"equal\": lambda a, b: safe_compare(a, b, torch.eq, lambda x, y: x == y),\n            \"not_equal\": lambda a, b: safe_compare(a, b, torch.ne, lambda x, y: x != y),\n        }\n\n        if operator not in operator_map:\n            raise ValueError(\n                f\"Invalid operator: {operator}. Valid operators are: {', '.join(operator_map.keys())}\"\n            )\n\n        output = operator_map[operator](input_a, input_b)\n\n        # Handle different output types\n        if isinstance(output, torch.Tensor):\n            output = output.all().item()\n        elif isinstance(output, (list, tuple)):\n            output = all(output)\n\n        return (bool(output),)\n</code></pre>"},{"location":"nodes/lora/","title":"Lora Nodes","text":""},{"location":"nodes/lora/#applylorastack","title":"ApplyLoraStack","text":"<p>A ComfyUI node that applies a stack of LoRA models to a base model and CLIP</p>"},{"location":"nodes/lora/#inputs","title":"Inputs","text":"Group Name Type Default Extras required model MODEL required clip CLIP required lora_stack LORA_STACK"},{"location":"nodes/lora/#returns","title":"Returns","text":"Name Type model <code>MODEL</code> clip <code>CLIP</code> Pick the code in lora.py <pre><code>class ApplyLoraStack:\n    \"\"\"\n    A ComfyUI node that applies a stack of LoRA models to a base model and CLIP.\n\n    Takes a model, CLIP, and a LORA_STACK as input and returns the modified model and CLIP\n    with all LoRAs applied in sequence using the specified weights.\n    \"\"\"\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"model\": (\"MODEL\",),\n                \"clip\": (\"CLIP\",),\n                \"lora_stack\": (\"LORA_STACK\",),\n            }\n        }\n\n    RETURN_TYPES = (\n        \"MODEL\",\n        \"CLIP\",\n    )\n    RETURN_NAMES = (\n        \"MODEL\",\n        \"CLIP\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = LORA_CAT\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        model = kwargs.get(\"model\")\n        clip = kwargs.get(\"clip\")\n        lora_stack = kwargs.get(\"lora_stack\")\n        loras = []\n        if lora_stack is None:\n            return (\n                model,\n                clip,\n            )\n\n        model_lora = model\n        clip_lora = clip\n        loras.extend(lora_stack)\n\n        for lora in loras:\n            lora_name, strength_model, strength_clip = lora\n\n            lora_path = folder_paths.get_full_path(\"loras\", lora_name)\n            lora = utils.load_torch_file(lora_path, safe_load=True)\n\n            model_lora, clip_lora = sd.load_lora_for_models(\n                model_lora, clip_lora, lora, strength_model, strength_clip\n            )\n\n        return (\n            model_lora,\n            clip_lora,\n        )\n</code></pre>"},{"location":"nodes/lora/#lorastack","title":"LoraStack","text":"<p>A ComfyUI node that creates a stack of up to 3 LoRA models with configurable weights</p>"},{"location":"nodes/lora/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required switch_1 required lora_name_1 required model_weight_1 FLOAT 1.0 max: 10.0, step: 0.01 required clip_weight_1 FLOAT 1.0 max: 10.0, step: 0.01 required switch_2 required lora_name_2 required model_weight_2 FLOAT 1.0 max: 10.0, step: 0.01 required clip_weight_2 FLOAT 1.0 max: 10.0, step: 0.01 required switch_3 required lora_name_3 required model_weight_3 FLOAT 1.0 max: 10.0, step: 0.01 required clip_weight_3 FLOAT 1.0 max: 10.0, step: 0.01 optional lora_stack LORA_STACK"},{"location":"nodes/lora/#returns_1","title":"Returns","text":"Name Type lora_stack <code>LORA_STACK</code> Pick the code in lora.py <pre><code>class LoraStack:\n    \"\"\"\n    A ComfyUI node that creates a stack of up to 3 LoRA models with configurable weights.\n\n    Allows users to enable/disable and configure model/CLIP weights for each LoRA.\n    Can optionally extend an existing LORA_STACK input. Returns a LORA_STACK that can be\n    used with ApplyLoraStack.\n    \"\"\"\n    @classmethod\n    def INPUT_TYPES(cls):\n        loras = [\"None\"] + folder_paths.get_filename_list(\"loras\")\n\n        return {\n            \"required\": {\n                \"switch_1\": ([\"Off\", \"On\"],),\n                \"lora_name_1\": (loras,),\n                \"model_weight_1\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n                \"clip_weight_1\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n                \"switch_2\": ([\"Off\", \"On\"],),\n                \"lora_name_2\": (loras,),\n                \"model_weight_2\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n                \"clip_weight_2\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n                \"switch_3\": ([\"Off\", \"On\"],),\n                \"lora_name_3\": (loras,),\n                \"model_weight_3\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n                \"clip_weight_3\": (\"FLOAT\", {\"default\": 1.0, \"min\": -10.0, \"max\": 10.0, \"step\": 0.01}),\n            },\n            \"optional\": {\"lora_stack\": (\"LORA_STACK\",)},\n        }\n\n    RETURN_TYPES = (\"LORA_STACK\",)\n    RETURN_NAMES = (\"lora_stack\",)\n    FUNCTION = \"execute\"\n    CATEGORY = LORA_CAT\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        switch_1 = kwargs.get(\"switch_1\")\n        lora_name_1 = kwargs.get(\"lora_name_1\")\n        model_weight_1 = kwargs.get(\"model_weight_1\")\n        clip_weight_1 = kwargs.get(\"clip_weight_1\")\n        switch_2 = kwargs.get(\"switch_2\")\n        lora_name_2 = kwargs.get(\"lora_name_2\")\n        model_weight_2 = kwargs.get(\"model_weight_2\")\n        clip_weight_2 = kwargs.get(\"clip_weight_2\")\n        switch_3 = kwargs.get(\"switch_3\")\n        lora_name_3 = kwargs.get(\"lora_name_3\")\n        model_weight_3 = kwargs.get(\"model_weight_3\")\n        clip_weight_3 = kwargs.get(\"clip_weight_3\")\n        lora_stack = kwargs.get(\"lora_stack\")\n\n        lora_list: list = []\n        if lora_stack is not None:\n            lora_list.extend([l for l in lora_stack if l[0] != \"None\"])\n\n        if lora_name_1 != \"None\" and switch_1 == \"On\":\n            lora_list.extend([(lora_name_1, model_weight_1, clip_weight_1)]),  # type: ignore\n\n        if lora_name_2 != \"None\" and switch_2 == \"On\":\n            lora_list.extend([(lora_name_2, model_weight_2, clip_weight_2)]),  # type: ignore\n\n        if lora_name_3 != \"None\" and switch_3 == \"On\":\n            lora_list.extend([(lora_name_3, model_weight_3, clip_weight_3)]),  # type: ignore\n\n        return (lora_list,)\n</code></pre>"},{"location":"nodes/lora/#dict2lorastack","title":"Dict2LoraStack","text":"<p>A ComfyUI node that converts a list of LoRA dictionaries into a LORA_STACK format</p>"},{"location":"nodes/lora/#returns_2","title":"Returns","text":"Name Type lora_stack <code>LORA_STACK</code> Pick the code in lora.py <pre><code>class Dict2LoraStack:\n    \"\"\"\n    A ComfyUI node that converts a list of LoRA dictionaries into a LORA_STACK format.\n\n    Each dictionary should contain 'lora_name' and 'lora_weight' keys.\n    Can optionally extend an existing LORA_STACK input.\n    \"\"\"\n    @classmethod\n    def INPUT_TYPES(cls):\n        inputs = {\n            \"required\": {\n                \"lora_dicts\": (\"LIST\",),\n            },\n            \"optional\": {\"lora_stack\": (\"LORA_STACK\",)},\n        }\n\n        inputs[\"optional\"] = {\"lora_stack\": (\"LORA_STACK\",)}\n        return inputs\n\n    RETURN_TYPES = (\"LORA_STACK\",)\n    RETURN_NAMES = (\"lora_stack\",)\n    FUNCTION = \"execute\"\n    CATEGORY = LORA_CAT\n\n    def execute(self, **kwargs):\n        lora_dicts = kwargs.get(\"lora_dicts\")\n        if not isinstance(lora_dicts, list):\n            raise ValueError(\"Lora dicts must be a list\")\n        lora_stack = kwargs.get(\"lora_stack\")\n        loras = [None for _ in lora_dicts]\n\n        for idx, lora_dict in enumerate(lora_dicts):\n            loras[idx] = (lora_dict[\"lora_name\"], lora_dict[\"lora_weight\"], lora_dict[\"lora_weight\"])  # type: ignore\n\n        # If lora_stack is not None, extend the loras list with lora_stack\n        if lora_stack is not None:\n            loras.extend([l for l in lora_stack if l[0] != \"None\"])\n\n        return (loras,)\n</code></pre>"},{"location":"nodes/lora/#saveloracaptions","title":"SaveLoraCaptions","text":"<p>A ComfyUI node that saves images and their associated captions for LoRA training</p>"},{"location":"nodes/lora/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required dataset_name STRING required repeats INT 5 min: 1 required images IMAGE required labels STRING forceInput: True optional prefix STRING optional suffix STRING"},{"location":"nodes/lora/#returns_3","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in lora.py <pre><code>class SaveLoraCaptions:\n    \"\"\"\n    A ComfyUI node that saves images and their associated captions for LoRA training.\n\n    Creates a dataset folder structure with:\n    - Images saved as PNG files\n    - Corresponding text files containing captions\n    - Optional prefix/suffix added to captions\n    - Support for multiple captions via newline separation\n\n    Returns the path to the created dataset folder.\n    \"\"\"\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"dataset_name\": (\"STRING\", {\"default\": \"\"}),\n                \"repeats\": (\"INT\", {\"default\": 5, \"min\": 1}),\n                \"images\": (\"IMAGE\",),\n                \"labels\": (\"STRING\", {\"forceInput\": True}),\n            },\n            \"optional\": {\n                \"prefix\": (\"STRING\", {\"default\": \"\"}),\n                \"suffix\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    RETURN_NAMES = (\"folder_path\",)\n    OUTPUT_NODE = True\n    FUNCTION = \"execute\"\n    CATEGORY = LORA_CAT\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        dataset_name = kwargs.get(\"dataset_name\")\n        if not isinstance(dataset_name, str):\n            raise ValueError(\"Dataset name must be a string\")\n        repeats = kwargs.get(\"repeats\")\n        if not isinstance(repeats, int):\n            raise ValueError(\"Repeats must be an integer\")\n        images = kwargs.get(\"images\")\n        if not isinstance(images, torch.Tensor):\n            raise ValueError(\"Images must be a torch.Tensor\")\n        labels = kwargs.get(\"labels\")\n        if not isinstance(labels, str):\n            raise ValueError(\"Labels must be a string\")\n        prefix = kwargs.get(\"prefix\")\n        if not isinstance(prefix, str):\n            raise ValueError(\"Prefix must be a string\")\n        suffix = kwargs.get(\"suffix\")\n        if not isinstance(suffix, str):\n            raise ValueError(\"Suffix must be a string\")\n\n        labels_list = labels.split(\"\\n\") if \"\\n\" in labels else [labels]\n\n        root_folder = os.path.join(BASE_COMFY_DIR, \"loras_datasets\")\n        if not os.path.exists(root_folder):\n            os.mkdir(root_folder)\n\n        uuid = uuid7str()\n        dataset_folder = os.path.join(root_folder, f\"{dataset_name}_{uuid}\")\n        if not os.path.exists(dataset_folder):\n            os.mkdir(dataset_folder)\n        images_folder = os.path.join(dataset_folder, f\"{repeats}_{dataset_name}\")\n        if not os.path.exists(images_folder):\n            os.mkdir(images_folder)\n\n        tensor_images = TensorImage.from_BWHC(images)\n        for i, img in enumerate(tensor_images):\n            # timestamp to be added to the image name\n\n            TensorImage(img).save(os.path.join(images_folder, f\"{dataset_name}_{i}.png\"))\n            # write txt label with the same name of the image\n            with open(os.path.join(images_folder, f\"{dataset_name}_{i}.txt\"), \"w\") as f:\n                label = prefix + labels_list[i % len(labels_list)] + suffix\n                f.write(label)\n\n        return (dataset_folder,)\n</code></pre>"},{"location":"nodes/mask/","title":"Mask Nodes","text":""},{"location":"nodes/mask/#basemask","title":"BaseMask","text":"<p>Creates a basic binary mask of specified dimensions</p>"},{"location":"nodes/mask/#inputs","title":"Inputs","text":"Group Name Type Default Extras required color required width INT 1024 min: 1, step: 1 required height INT 1024 min: 1, step: 1"},{"location":"nodes/mask/#returns","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class BaseMask:\n    \"\"\"Creates a basic binary mask of specified dimensions.\n\n    Parameters:\n        color (str): Either \"white\" or \"black\" to set mask color\n        width (int): Width of the output mask (default: 1024)\n        height (int): Height of the output mask (default: 1024)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing a binary mask in BWHC format\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"color\": ([\"white\", \"black\"],),\n                \"width\": (\"INT\", {\"default\": 1024, \"min\": 1, \"max\": MAX_INT, \"step\": 1}),\n                \"height\": (\"INT\", {\"default\": 1024, \"min\": 1, \"max\": MAX_INT, \"step\": 1}),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, **kwargs):\n        color = kwargs.get(\"color\") or \"white\"\n        width = kwargs.get(\"width\") or 1024\n        height = kwargs.get(\"height\") or 1024\n        if color == \"white\":\n            mask = torch.ones(1, 1, height, width)\n        else:\n            mask = torch.zeros(1, 1, height, width)\n        mask = TensorImage(mask).get_BWHC()\n        return (mask,)\n</code></pre>"},{"location":"nodes/mask/#maskmorphology","title":"MaskMorphology","text":"<p>Applies morphological operations to a mask</p>"},{"location":"nodes/mask/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required mask MASK required operation required kernel_size INT 1 min: 1, step: 2 required iterations INT 5 min: 1, step: 1"},{"location":"nodes/mask/#returns_1","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskMorphology:\n    \"\"\"Applies morphological operations to a mask.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n        operation (str): One of: \"dilation\", \"erosion\", \"opening\", \"closing\",\n                        \"gradient\", \"top_hat\", \"bottom_hat\"\n        kernel_size (int): Size of the morphological kernel (default: 1)\n        iterations (int): Number of times to apply the operation (default: 5)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the processed mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n                \"operation\": (\n                    [\n                        \"dilation\",\n                        \"erosion\",\n                        \"opening\",\n                        \"closing\",\n                        \"gradient\",\n                        \"top_hat\",\n                        \"bottom_hat\",\n                    ],\n                ),\n                \"kernel_size\": (\n                    \"INT\",\n                    {\"default\": 1, \"min\": 1, \"max\": MAX_INT, \"step\": 2},\n                ),\n                \"iterations\": (\n                    \"INT\",\n                    {\"default\": 5, \"min\": 1, \"max\": MAX_INT, \"step\": 1},\n                ),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, **kwargs):\n        mask = kwargs.get(\"mask\")\n        if not isinstance(mask, torch.Tensor):\n            raise ValueError(\"Mask must be a tensor\")\n        kernel = kwargs.get(\"kernel_size\")\n        iterations = kwargs.get(\"iterations\")\n        operation = kwargs.get(\"operation\")\n        step = TensorImage.from_BWHC(mask)\n\n        if operation == \"dilation\":\n            output = dilation(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"erosion\":\n            output = erosion(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"opening\":\n            output = opening(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"closing\":\n            output = closing(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"gradient\":\n            output = gradient(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"top_hat\":\n            output = top_hat(image=step, kernel_size=kernel, iterations=iterations)\n        elif operation == \"bottom_hat\":\n            output = bottom_hat(image=step, kernel_size=kernel, iterations=iterations)\n        else:\n            raise ValueError(\"Invalid operation\")\n        return (output.get_BWHC(),)\n</code></pre>"},{"location":"nodes/mask/#maskbitwise","title":"MaskBitwise","text":"<p>Performs bitwise operations between two masks</p>"},{"location":"nodes/mask/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required mask_1 MASK required mask_2 MASK required mode"},{"location":"nodes/mask/#returns_2","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskBitwise:\n    \"\"\"Performs bitwise operations between two masks.\n\n    Parameters:\n        mask_1 (torch.Tensor): First input mask in BWHC format\n        mask_2 (torch.Tensor): Second input mask in BWHC format\n        mode (str): One of: \"and\", \"or\", \"xor\", \"left_shift\", \"right_shift\"\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the resulting mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask_1\": (\"MASK\",),\n                \"mask_2\": (\"MASK\",),\n                \"mode\": ([\"and\", \"or\", \"xor\", \"left_shift\", \"right_shift\"],),\n            },\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask_1: torch.Tensor, mask_2: torch.Tensor, mode: str):\n        input_mask_1 = TensorImage.from_BWHC(mask_1)\n        input_mask_2 = TensorImage.from_BWHC(mask_2)\n        eight_bit_mask_1 = torch.tensor(input_mask_1 * 255, dtype=torch.uint8)\n        eight_bit_mask_2 = torch.tensor(input_mask_2 * 255, dtype=torch.uint8)\n\n        if mode == \"and\":\n            result = torch.bitwise_and(eight_bit_mask_1, eight_bit_mask_2)\n        elif mode == \"or\":\n            result = torch.bitwise_or(eight_bit_mask_1, eight_bit_mask_2)\n        elif mode == \"xor\":\n            result = torch.bitwise_xor(eight_bit_mask_1, eight_bit_mask_2)\n        elif mode == \"left_shift\":\n            result = torch.bitwise_left_shift(eight_bit_mask_1, eight_bit_mask_2)\n        elif mode == \"right_shift\":\n            result = torch.bitwise_right_shift(eight_bit_mask_1, eight_bit_mask_2)\n        else:\n            raise ValueError(\"Invalid mode\")\n\n        float_result = result.float() / 255\n        output_mask = TensorImage(float_result).get_BWHC()\n        return (output_mask,)\n</code></pre>"},{"location":"nodes/mask/#maskdistance","title":"MaskDistance","text":"<p>Calculates the Euclidean distance between two masks</p>"},{"location":"nodes/mask/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required mask_0 MASK required mask_1 MASK"},{"location":"nodes/mask/#returns_3","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in mask.py <pre><code>class MaskDistance:\n    \"\"\"Calculates the Euclidean distance between two masks.\n\n    Parameters:\n        mask_0 (torch.Tensor): First input mask in BWHC format\n        mask_1 (torch.Tensor): Second input mask in BWHC format\n\n    Returns:\n        tuple[float]: Single-element tuple containing the distance value\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\"required\": {\"mask_0\": (\"MASK\",), \"mask_1\": (\"MASK\",)}}\n\n    RETURN_TYPES = (\"FLOAT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, **kwargs):\n        mask_0 = kwargs.get(\"mask_0\")\n        mask_1 = kwargs.get(\"mask_1\")\n        if not isinstance(mask_0, torch.Tensor) or not isinstance(mask_1, torch.Tensor):\n            raise ValueError(\"Mask must be a tensor\")\n        tensor1 = TensorImage.from_BWHC(mask_0)\n        tensor2 = TensorImage.from_BWHC(mask_1)\n        dist = torch.Tensor((tensor1 - tensor2).pow(2).sum(3).sqrt().mean())\n        return (dist,)\n</code></pre>"},{"location":"nodes/mask/#mask2trimap","title":"Mask2Trimap","text":"<p>Converts a mask to a trimap representation (foreground, background, unknown regions)</p>"},{"location":"nodes/mask/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required mask MASK required inner_min_threshold INT 200 min: 0, max: 255 required inner_max_threshold INT 255 min: 0, max: 255 required outer_min_threshold INT 15 min: 0, max: 255 required outer_max_threshold INT 240 min: 0, max: 255 required kernel_size INT 10 min: 1, max: 100"},{"location":"nodes/mask/#returns_4","title":"Returns","text":"Name Type mask <code>MASK</code> trimap <code>TRIMAP</code> Pick the code in mask.py <pre><code>class Mask2Trimap:\n    \"\"\"Converts a mask to a trimap representation (foreground, background, unknown regions).\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n        inner_min_threshold (int): Minimum threshold for inner region (default: 200)\n        inner_max_threshold (int): Maximum threshold for inner region (default: 255)\n        outer_min_threshold (int): Minimum threshold for outer region (default: 15)\n        outer_max_threshold (int): Maximum threshold for outer region (default: 240)\n        kernel_size (int): Size of morphological kernel (default: 10)\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: Mask and trimap tensors\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n                \"inner_min_threshold\": (\"INT\", {\"default\": 200, \"min\": 0, \"max\": 255}),\n                \"inner_max_threshold\": (\"INT\", {\"default\": 255, \"min\": 0, \"max\": 255}),\n                \"outer_min_threshold\": (\"INT\", {\"default\": 15, \"min\": 0, \"max\": 255}),\n                \"outer_max_threshold\": (\"INT\", {\"default\": 240, \"min\": 0, \"max\": 255}),\n                \"kernel_size\": (\"INT\", {\"default\": 10, \"min\": 1, \"max\": 100}),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\", \"TRIMAP\")\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, **kwargs):\n        mask = kwargs.get(\"mask\")\n        inner_min_threshold = kwargs.get(\"inner_min_threshold\") or 200\n        inner_max_threshold = kwargs.get(\"inner_max_threshold\") or 255\n        outer_min_threshold = kwargs.get(\"outer_min_threshold\") or 15\n        outer_max_threshold = kwargs.get(\"outer_max_threshold\") or 240\n        kernel_size = kwargs.get(\"kernel_size\")\n\n        if not isinstance(mask, torch.Tensor):\n            raise ValueError(\"Mask must be a tensor\")\n\n        step = TensorImage.from_BWHC(mask)\n        inner_mask = TensorImage(step.clone())\n        inner_mask[inner_mask &gt; (inner_max_threshold / 255.0)] = 1.0\n        inner_mask[inner_mask &lt;= (inner_min_threshold / 255.0)] = 0.0\n\n        step = TensorImage.from_BWHC(mask)\n        inner_mask = erosion(image=inner_mask, kernel_size=kernel_size, iterations=1)\n\n        inner_mask[inner_mask != 0.0] = 1.0\n\n        outter_mask = step.clone()\n        outter_mask[outter_mask &gt; (outer_max_threshold / 255.0)] = 1.0\n        outter_mask[outter_mask &lt;= (outer_min_threshold / 255.0)] = 0.0\n        outter_mask = dilation(image=inner_mask, kernel_size=kernel_size, iterations=5)\n\n        outter_mask[outter_mask != 0.0] = 1.0\n\n        trimap_im = torch.zeros_like(step)\n        trimap_im[outter_mask == 1.0] = 0.5\n        trimap_im[inner_mask == 1.0] = 1.0\n        batch_size = step.shape[0]\n\n        trimap = torch.zeros(\n            batch_size, 2, step.shape[2], step.shape[3], dtype=step.dtype, device=step.device\n        )\n        for i in range(batch_size):\n            tar_trimap = trimap_im[i][0]\n            trimap[i][1][tar_trimap == 1] = 1\n            trimap[i][0][tar_trimap == 0] = 1\n\n        output_0 = TensorImage(trimap_im).get_BWHC()\n        output_1 = trimap.permute(0, 2, 3, 1)\n\n        return (\n            output_0,\n            output_1,\n        )\n</code></pre>"},{"location":"nodes/mask/#maskbinaryfilter","title":"MaskBinaryFilter","text":"<p>Applies binary thresholding to a mask</p>"},{"location":"nodes/mask/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required mask MASK required threshold FLOAT 0.01 min: 0.0, max: 1.0, step: 0.01"},{"location":"nodes/mask/#returns_5","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskBinaryFilter:\n    \"\"\"Applies binary thresholding to a mask.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n        threshold (float): Threshold value between 0 and 1 (default: 0.01)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the binary mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n                \"threshold\": (\"FLOAT\", {\"default\": 0.01, \"min\": 0.00, \"max\": 1.00, \"step\": 0.01}),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask: torch.Tensor, threshold: float):\n        step = TensorImage.from_BWHC(mask)\n        step[step &gt; threshold] = 1.0\n        step[step &lt;= threshold] = 0.0\n        output = TensorImage(step).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/mask/#maskinvert","title":"MaskInvert","text":"<p>Inverts a mask (1 becomes 0 and vice versa)</p>"},{"location":"nodes/mask/#inputs_6","title":"Inputs","text":"Group Name Type Default Extras required mask MASK"},{"location":"nodes/mask/#returns_6","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskInvert:\n    \"\"\"Inverts a mask (1 becomes 0 and vice versa).\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the inverted mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask: torch.Tensor):\n        step = TensorImage.from_BWHC(mask)\n        step = 1.0 - step\n        output = TensorImage(step).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/mask/#maskgaussianblur","title":"MaskGaussianBlur","text":"<p>Applies Gaussian blur to a mask</p>"},{"location":"nodes/mask/#inputs_7","title":"Inputs","text":"Group Name Type Default Extras required image MASK required radius INT 13 required sigma FLOAT 10.5 required interations INT 1 required only_outline BOOLEAN False"},{"location":"nodes/mask/#returns_7","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskGaussianBlur:\n    \"\"\"Applies Gaussian blur to a mask.\n\n    Parameters:\n        image (torch.Tensor): Input mask in BWHC format\n        radius (int): Blur radius (default: 13)\n        sigma (float): Blur sigma/strength (default: 10.5)\n        iterations (int): Number of blur passes (default: 1)\n        only_outline (bool): Whether to blur only the outline (default: False)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the blurred mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"MASK\",),\n                \"radius\": (\"INT\", {\"default\": 13}),\n                \"sigma\": (\"FLOAT\", {\"default\": 10.5}),\n                \"interations\": (\"INT\", {\"default\": 1}),\n                \"only_outline\": (\"BOOLEAN\", {\"default\": False}),\n            }\n        }\n\n    RETURN_TYPES = (\"MASK\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, image: torch.Tensor, radius, sigma, interations):\n        tensor_image = TensorImage.from_BWHC(image)\n        output = gaussian_blur2d(tensor_image, radius, sigma, interations).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/mask/#mask2image","title":"Mask2Image","text":"<p>Converts a single-channel mask to a 3-channel image</p>"},{"location":"nodes/mask/#inputs_8","title":"Inputs","text":"Group Name Type Default Extras required mask MASK"},{"location":"nodes/mask/#returns_8","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in mask.py <pre><code>class Mask2Image:\n    \"\"\"Converts a single-channel mask to a 3-channel image.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the converted image\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask: torch.Tensor):\n        mask_tensor = TensorImage.from_BWHC(mask)\n        output = mask_tensor.repeat(1, 3, 1, 1)\n        output = TensorImage(output).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/mask/#maskgrowwithblur","title":"MaskGrowWithBlur","text":"<p>Expands or contracts a mask with optional blur and tapering effects</p>"},{"location":"nodes/mask/#inputs_9","title":"Inputs","text":"Group Name Type Default Extras required mask MASK required expand INT 0 step: 1 required incremental_expandrate FLOAT 0.0 min: 0.0, max: 100.0, step: 0.1 required tapered_corners BOOLEAN True required flip_input BOOLEAN False required blur_radius FLOAT 0.0 min: 0.0, max: 100, step: 0.1 required lerp_alpha FLOAT 1.0 min: 0.0, max: 1.0, step: 0.01 required decay_factor FLOAT 1.0 min: 0.0, max: 1.0, step: 0.01"},{"location":"nodes/mask/#returns_9","title":"Returns","text":"Name Type mask <code>MASK</code> Pick the code in mask.py <pre><code>class MaskGrowWithBlur:\n    \"\"\"Expands or contracts a mask with optional blur and tapering effects.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n        expand (int): Pixels to expand (positive) or contract (negative)\n        incremental_expandrate (float): Rate of expansion per iteration\n        tapered_corners (bool): Whether to taper corners (default: True)\n        flip_input (bool): Whether to invert input before processing (default: False)\n        blur_radius (float): Radius for final blur (default: 0.0)\n        lerp_alpha (float): Linear interpolation factor (default: 1.0)\n        decay_factor (float): Decay factor for expansion (default: 1.0)\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the processed mask\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n                \"expand\": (\n                    \"INT\",\n                    {\n                        \"default\": 0,\n                        \"min\": -MAX_INT,\n                        \"max\": MAX_INT,\n                        \"step\": 1,\n                    },\n                ),\n                \"incremental_expandrate\": (\n                    \"FLOAT\",\n                    {\"default\": 0.0, \"min\": 0.0, \"max\": 100.0, \"step\": 0.1},\n                ),\n                \"tapered_corners\": (\"BOOLEAN\", {\"default\": True}),\n                \"flip_input\": (\"BOOLEAN\", {\"default\": False}),\n                \"blur_radius\": (\n                    \"FLOAT\",\n                    {\"default\": 0.0, \"min\": 0.0, \"max\": 100, \"step\": 0.1},\n                ),\n                \"lerp_alpha\": (\n                    \"FLOAT\",\n                    {\"default\": 1.0, \"min\": 0.0, \"max\": 1.0, \"step\": 0.01},\n                ),\n                \"decay_factor\": (\n                    \"FLOAT\",\n                    {\"default\": 1.0, \"min\": 0.0, \"max\": 1.0, \"step\": 0.01},\n                ),\n            },\n        }\n\n    CATEGORY = MASK_CAT\n    RETURN_TYPES = (\"MASK\",)\n    RETURN_NAMES = (\"mask\",)\n    FUNCTION = \"expand_mask\"\n\n    def expand_mask(self, **kwargs):\n        mask = kwargs.get(\"mask\")\n        if not isinstance(mask, torch.Tensor):\n            raise ValueError(\"Mask must be a tensor\")\n        expand = kwargs.get(\"expand\")\n        if not isinstance(expand, int):\n            raise ValueError(\"Expand must be an integer\")\n        incremental_expandrate = kwargs.get(\"incremental_expandrate\")\n        if not isinstance(incremental_expandrate, float):\n            raise ValueError(\"Incremental expandrate must be a float\")\n        tapered_corners = kwargs.get(\"tapered_corners\")\n        if not isinstance(tapered_corners, bool):\n            raise ValueError(\"Tapered corners must be a boolean\")\n        flip_input = kwargs.get(\"flip_input\")\n        if not isinstance(flip_input, bool):\n            raise ValueError(\"Flip input must be a boolean\")\n        blur_radius = kwargs.get(\"blur_radius\")\n        if not isinstance(blur_radius, float):\n            raise ValueError(\"Blur radius must be a float\")\n        lerp_alpha = kwargs.get(\"lerp_alpha\")\n        if not isinstance(lerp_alpha, float):\n            raise ValueError(\"Lerp alpha must be a float\")\n        decay_factor = kwargs.get(\"decay_factor\")\n        if not isinstance(decay_factor, float):\n            raise ValueError(\"Decay factor must be a float\")\n        mask = TensorImage.from_BWHC(mask)\n        alpha = lerp_alpha\n        decay = decay_factor\n        if flip_input:\n            mask = 1.0 - mask\n        c = 0 if tapered_corners else 1\n        kernel = torch.tensor([[c, 1, c], [1, 1, 1], [c, 1, c]], dtype=torch.float32)\n        growmask = mask.reshape((-1, mask.shape[-2], mask.shape[-1])).cpu()\n        out = []\n        previous_output = None\n        current_expand = expand\n        for m in growmask:\n            m = m.unsqueeze(0).unsqueeze(0)\n            output = m.clone()\n\n            for _ in range(abs(round(current_expand))):\n                if current_expand &lt; 0:\n                    output = morphology.erosion(output, kernel)\n                else:\n                    output = morphology.dilation(output, kernel)\n            if current_expand &lt; 0:\n                current_expand -= abs(incremental_expandrate)\n            else:\n                current_expand += abs(incremental_expandrate)\n\n            output = output.squeeze(0).squeeze(0)\n\n            if alpha &lt; 1.0 and previous_output is not None:\n                output = alpha * output + (1 - alpha) * previous_output\n            if decay &lt; 1.0 and previous_output is not None:\n                output += decay * previous_output\n                output = output / output.max()\n            previous_output = output\n            out.append(output)\n\n        if blur_radius != 0:\n            kernel_size = int(4 * round(blur_radius) + 1)\n            blurred = [\n                filters.gaussian_blur2d(\n                    tensor.unsqueeze(0).unsqueeze(0), (kernel_size, kernel_size), (blur_radius, blur_radius)\n                ).squeeze(0)\n                for tensor in out\n            ]\n            blurred = torch.cat(blurred, dim=0)\n\n            return (TensorImage(blurred).get_BWHC(),)\n\n        return (TensorImage(torch.stack(out, dim=0)).get_BWHC(),)\n</code></pre>"},{"location":"nodes/mask/#getmaskshape","title":"GetMaskShape","text":"<p>Returns the dimensions of an input mask</p>"},{"location":"nodes/mask/#inputs_10","title":"Inputs","text":"Group Name Type Default Extras required mask MASK"},{"location":"nodes/mask/#returns_10","title":"Returns","text":"Name Type int <code>INT</code> int <code>INT</code> int <code>INT</code> int <code>INT</code> string <code>STRING</code> Pick the code in mask.py <pre><code>class GetMaskShape:\n    \"\"\"Returns the dimensions of an input mask.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n\n    Returns:\n        tuple[int, int, int, int, str]: Batch size, width, height, channels, and shape string\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n            },\n        }\n\n    RETURN_TYPES = (\"INT\", \"INT\", \"INT\", \"INT\", \"STRING\")\n    RETURN_NAMES = (\"batch\", \"width\", \"height\", \"channels\", \"debug\")\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask):\n        if len(mask.shape) == 3:\n            return (mask.shape[0], mask.shape[2], mask.shape[1], 1, str(mask.shape))\n        return (mask.shape[0], mask.shape[2], mask.shape[1], mask.shape[3], str(mask.shape))\n</code></pre>"},{"location":"nodes/mask/#maskpreview","title":"MaskPreview","text":"<p>Saves a preview of a mask as an image file</p>"},{"location":"nodes/mask/#inputs_11","title":"Inputs","text":"Group Name Type Default Extras required mask MASK Pick the code in mask.py <pre><code>class MaskPreview(SaveImage):\n    \"\"\"Saves a preview of a mask as an image file.\n\n    Parameters:\n        mask (torch.Tensor): Input mask in BWHC format\n        filename_prefix (str): Prefix for the output filename (default: \"Signature\")\n        prompt (Optional[str]): Optional prompt to include in metadata\n        extra_pnginfo (Optional[dict]): Additional PNG metadata\n\n    Returns:\n        tuple[str, str]: Paths to the saved preview images\n    \"\"\"\n\n    def __init__(self):\n        self.output_dir = folder_paths.get_temp_directory()\n        self.type = \"temp\"\n        self.prefix_append = \"_temp_\" + \"\".join(random.choice(\"abcdefghijklmnopqrstupvxyz\") for _ in range(5))\n        self.compress_level = 4\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"mask\": (\"MASK\",),\n            },\n            \"hidden\": {\"prompt\": \"PROMPT\", \"extra_pnginfo\": \"EXTRA_PNGINFO\"},\n        }\n\n    FUNCTION = \"execute\"\n    CATEGORY = MASK_CAT\n\n    def execute(self, mask, filename_prefix=\"Signature\", prompt=None, extra_pnginfo=None):\n        preview = TensorImage.from_BWHC(mask).get_rgb_or_rgba().get_BWHC()\n        return self.save_images(preview, filename_prefix, prompt, extra_pnginfo)\n</code></pre>"},{"location":"nodes/models/","title":"Models Nodes","text":""},{"location":"nodes/models/#magiceraser","title":"MagicEraser","text":"<p>Removes content from an image based on a mask using the Lama inpainting model</p>"},{"location":"nodes/models/#inputs","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required mask MASK required preview"},{"location":"nodes/models/#returns","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in models.py <pre><code>class MagicEraser(SaveImage):\n    \"\"\"Removes content from an image based on a mask using the Lama inpainting model.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        mask (torch.Tensor): Mask indicating areas to erase\n        preview (str): Whether to save preview images (\"on\" or \"off\")\n        filename_prefix (str, optional): Prefix for saved files\n        prompt (str, optional): Optional prompt for metadata\n        extra_pnginfo (dict, optional): Additional PNG metadata\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the processed image\n    \"\"\"\n\n    def __init__(self):\n        self.output_dir = folder_paths.get_temp_directory()\n        self.type = \"temp\"\n        self.prefix_append = \"_temp_\" + \"\".join(random.choice(\"abcdefghijklmnopqrstupvxyz\") for x in range(5))\n        self.compress_level = 4\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"mask\": (\"MASK\",),\n                \"preview\": ([\"on\", \"off\"],),\n            },\n            \"hidden\": {\"prompt\": \"PROMPT\", \"extra_pnginfo\": \"EXTRA_PNGINFO\"},\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MODELS_CAT\n\n    def execute(\n        self,\n        image: torch.Tensor,\n        mask: torch.Tensor,\n        preview: str,\n        filename_prefix=\"Signature\",\n        prompt=None,\n        extra_pnginfo=None,\n    ):\n        model = Lama()\n        input_image = TensorImage.from_BWHC(image)\n        input_mask = TensorImage.from_BWHC(mask)\n        highres = TensorImage(model.forward(input_image, input_mask, \"FIXED\"))\n        output_images = highres.get_BWHC()\n        if preview == \"off\":\n            return (output_images,)\n        result = self.save_images(output_images, filename_prefix, prompt, extra_pnginfo)\n        result.update({\"result\": (output_images,)})\n        del model\n        model = None\n        return result\n</code></pre>"},{"location":"nodes/models/#unblur","title":"Unblur","text":"<p>Reduces blur in an image using the SeeMore model</p>"},{"location":"nodes/models/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE required preview"},{"location":"nodes/models/#returns_1","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in models.py <pre><code>class Unblur(SaveImage):\n    \"\"\"Reduces blur in an image using the SeeMore model.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        preview (str): Whether to save preview images (\"on\" or \"off\")\n        filename_prefix (str, optional): Prefix for saved files\n        prompt (str, optional): Optional prompt for metadata\n        extra_pnginfo (dict, optional): Additional PNG metadata\n\n    Returns:\n        tuple[torch.Tensor]: Single-element tuple containing the unblurred image\n    \"\"\"\n\n    def __init__(self):\n        self.output_dir = folder_paths.get_temp_directory()\n        self.type = \"temp\"\n        self.prefix_append = \"_temp_\" + \"\".join(random.choice(\"abcdefghijklmnopqrstupvxyz\") for x in range(5))\n        self.compress_level = 4\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n                \"preview\": ([\"on\", \"off\"],),\n            },\n            \"hidden\": {\"prompt\": \"PROMPT\", \"extra_pnginfo\": \"EXTRA_PNGINFO\"},\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = MODELS_CAT\n\n    def execute(\n        self, image: torch.Tensor, preview: str, filename_prefix=\"Signature\", prompt=None, extra_pnginfo=None\n    ):\n        model = SeeMore()\n        input_image = TensorImage.from_BWHC(image)\n        output_image = model.forward(input_image)\n        output_images = TensorImage(output_image).get_BWHC()\n\n        if preview == \"off\":\n            return (output_images,)\n        result = self.save_images(output_images, filename_prefix, prompt, extra_pnginfo)\n        result.update({\"result\": (output_images,)})\n        del model\n        model = None\n        return result\n</code></pre>"},{"location":"nodes/models/#backgroundremoval","title":"BackgroundRemoval","text":"<p>Removes the background from an image using various AI models</p>"},{"location":"nodes/models/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required model_name required preview required image IMAGE"},{"location":"nodes/models/#returns_2","title":"Returns","text":"Name Type image <code>IMAGE</code> image <code>IMAGE</code> mask <code>MASK</code> Pick the code in models.py <pre><code>class BackgroundRemoval(SaveImage):\n    \"\"\"Removes the background from an image using various AI models.\n\n    Parameters:\n        image (torch.Tensor): Input image in BWHC format\n        model_name (str): Model to use (\"inspyrenet\", \"rmbg14\", \"isnet_general\", \"fakepng\")\n        preview (str): Preview mode (\"mask\", \"rgba\", \"none\")\n        filename_prefix (str, optional): Prefix for saved files\n        prompt (str, optional): Optional prompt for metadata\n        extra_pnginfo (dict, optional): Additional PNG metadata\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor, torch.Tensor]: RGBA, RGB, and mask versions of the processed image\n    \"\"\"\n\n    def __init__(self):\n        self.output_dir = folder_paths.get_temp_directory()\n        self.type = \"temp\"\n        self.prefix_append = \"_temp_\" + \"\".join(random.choice(\"abcdefghijklmnopqrstupvxyz\") for _ in range(5))\n        self.compress_level = 4\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"model_name\": ([\"inspyrenet\", \"rmbg14\", \"isnet_general\", \"fakepng\"],),\n                \"preview\": ([\"mask\", \"rgba\", \"none\"],),\n                \"image\": (\"IMAGE\",),\n            },\n            \"hidden\": {\"prompt\": \"PROMPT\", \"extra_pnginfo\": \"EXTRA_PNGINFO\"},\n        }\n\n    RETURN_TYPES = (\"IMAGE\", \"IMAGE\", \"MASK\")\n    RETURN_NAMES = (\"rgba\", \"rgb\", \"mask\")\n    FUNCTION = \"execute\"\n    CATEGORY = MODELS_CAT\n\n    def execute(\n        self,\n        image: torch.Tensor,\n        model_name: str,\n        preview: str,\n        filename_prefix=\"Signature\",\n        prompt=None,\n        extra_pnginfo=None,\n    ):\n\n        model = SalientObjectDetection(model_name=model_name)\n        input_image = TensorImage.from_BWHC(image)\n        masks = model.forward(input_image)\n\n        output_masks = TensorImage(masks)\n        rgb, rgba = cutout(input_image, output_masks)\n        rgb_output = TensorImage(rgb).get_BWHC()\n        rgba_output = TensorImage(rgba).get_BWHC()\n        mask_output = output_masks.get_BWHC()\n        if preview == \"none\":\n            return (\n                rgba_output,\n                rgb_output,\n                mask_output,\n            )\n        preview_images = output_masks.get_rgb_or_rgba().get_BWHC() if preview == \"mask\" else rgba_output\n        result = self.save_images(preview_images, filename_prefix, prompt, extra_pnginfo)\n        result.update(\n            {\n                \"result\": (\n                    rgba_output,\n                    rgb_output,\n                    mask_output,\n                )\n            }\n        )\n        del model\n        model = None\n        return result\n</code></pre>"},{"location":"nodes/numbers/","title":"Numbers Nodes","text":""},{"location":"nodes/numbers/#intclamp","title":"IntClamp","text":"<p>Clamps an integer within a specified range</p>"},{"location":"nodes/numbers/#inputs","title":"Inputs","text":"Group Name Type Default Extras required number INT 0 forceInput: True required min_value INT 0 step: 1 required max_value INT 0 step: 1"},{"location":"nodes/numbers/#returns","title":"Returns","text":"Name Type int <code>INT</code> Pick the code in numbers.py <pre><code>class IntClamp:\n    \"\"\"Clamps an integer within a specified range.\n\n    This class ensures that an integer input is clamped between a minimum and maximum value.\n\n    Methods:\n        execute(**kwargs): Returns the clamped integer value.\n\n    Raises:\n        ValueError: If the input values are not integers.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"number\": (\n                    \"INT\",\n                    {\n                        \"default\": 0,\n                        \"forceInput\": True,\n                        \"min\": -MAX_INT,\n                        \"max\": MAX_INT,\n                    },\n                ),\n                \"min_value\": (\n                    \"INT\",\n                    {\"default\": 0, \"min\": -MAX_INT, \"max\": MAX_INT, \"step\": 1},\n                ),\n                \"max_value\": (\n                    \"INT\",\n                    {\"default\": 0, \"min\": -MAX_INT, \"max\": MAX_INT, \"step\": 1},\n                ),\n            }\n        }\n\n    RETURN_TYPES = (\"INT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        number = kwargs.get(\"number\")\n        if not isinstance(number, int):\n            raise ValueError(\"Number must be an integer\")\n        min_value = kwargs.get(\"min_value\")\n        if not isinstance(min_value, int):\n            raise ValueError(\"Min value must be an integer\")\n        max_value = kwargs.get(\"max_value\")\n        if not isinstance(max_value, int):\n            raise ValueError(\"Max value must be an integer\")\n        if number &lt; min_value:\n            return (min_value,)\n        if number &gt; max_value:\n            return (max_value,)\n        return (number,)\n</code></pre>"},{"location":"nodes/numbers/#floatclamp","title":"FloatClamp","text":"<p>Clamps a float within a specified range</p>"},{"location":"nodes/numbers/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required number FLOAT 0 forceInput: True required min_value FLOAT 0 step: 0.01 required max_value FLOAT 0 step: 0.01"},{"location":"nodes/numbers/#returns_1","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class FloatClamp:\n    \"\"\"Clamps a float within a specified range.\n\n    This class ensures that a float input is clamped between a minimum and maximum value.\n\n    Methods:\n        execute(**kwargs): Returns the clamped float value.\n\n    Raises:\n        ValueError: If the input values are not floats.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"number\": (\n                    \"FLOAT\",\n                    {\n                        \"default\": 0,\n                        \"forceInput\": True,\n                        \"min\": -MAX_FLOAT,\n                        \"max\": MAX_FLOAT,\n                    },\n                ),\n                \"min_value\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n                \"max_value\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n            }\n        }\n\n    RETURN_TYPES = (\"FLOAT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        number = kwargs.get(\"number\")\n        if not isinstance(number, float):\n            raise ValueError(\"Number must be a float\")\n        min_value = kwargs.get(\"min_value\")\n        if not isinstance(min_value, float):\n            raise ValueError(\"Min value must be a float\")\n        max_value = kwargs.get(\"max_value\")\n        if not isinstance(max_value, float):\n            raise ValueError(\"Max value must be a float\")\n\n        if number &lt; min_value:\n            return (min_value,)\n        if number &gt; max_value:\n            return (max_value,)\n        return (number,)\n</code></pre>"},{"location":"nodes/numbers/#float2int","title":"Float2Int","text":"<p>Converts a float to an integer</p>"},{"location":"nodes/numbers/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required number FLOAT 0 forceInput: True"},{"location":"nodes/numbers/#returns_2","title":"Returns","text":"Name Type int <code>INT</code> Pick the code in numbers.py <pre><code>class Float2Int:\n    \"\"\"Converts a float to an integer.\n\n    This class converts a floating-point number to an integer by truncating the decimal part.\n\n    Methods:\n        execute(**kwargs): Returns the integer representation of the float.\n\n    Raises:\n        ValueError: If the input value is not a float.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"number\": (\"FLOAT\", {\"default\": 0, \"forceInput\": True}),\n            }\n        }\n\n    RETURN_TYPES = (\"INT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        number = kwargs.get(\"number\")\n        if not isinstance(number, float):\n            raise ValueError(\"Number must be a float\")\n        return (int(number),)\n</code></pre>"},{"location":"nodes/numbers/#int2float","title":"Int2Float","text":"<p>Converts an integer to a float</p>"},{"location":"nodes/numbers/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required number INT 0 forceInput: True"},{"location":"nodes/numbers/#returns_3","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class Int2Float:\n    \"\"\"Converts an integer to a float.\n\n    This class converts an integer to a floating-point number.\n\n    Methods:\n        execute(**kwargs): Returns the float representation of the integer.\n\n    Raises:\n        ValueError: If the input value is not an integer.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"number\": (\"INT\", {\"default\": 0, \"forceInput\": True}),\n            }\n        }\n\n    RETURN_TYPES = (\"FLOAT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        number = kwargs.get(\"number\")\n        if not isinstance(number, int):\n            raise ValueError(\"Number must be an integer\")\n        return (float(number),)\n</code></pre>"},{"location":"nodes/numbers/#intoperator","title":"IntOperator","text":"<p>Performs arithmetic operations on two floats and returns an integer</p>"},{"location":"nodes/numbers/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required left FLOAT 0 step: 0.01 required right FLOAT 0 step: 0.01 required operator"},{"location":"nodes/numbers/#returns_4","title":"Returns","text":"Name Type int <code>INT</code> Pick the code in numbers.py <pre><code>class IntOperator:\n    \"\"\"Performs arithmetic operations on two floats and returns an integer.\n\n    This class supports basic arithmetic operations (+, -, *, /) on two float inputs\n    and returns the result as an integer.\n\n    Methods:\n        execute(**kwargs): Returns the result of the arithmetic operation.\n\n    Raises:\n        ValueError: If the input values are not floats or if the operator is unsupported.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"left\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n                \"right\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n                \"operator\": ([\"+\", \"-\", \"*\", \"/\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"INT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        left = kwargs.get(\"left\")\n        if not isinstance(left, float):\n            raise ValueError(\"Left must be a float\")\n        right = kwargs.get(\"right\")\n        if not isinstance(right, float):\n            raise ValueError(\"Right must be a float\")\n        operator = kwargs.get(\"operator\")\n        if not isinstance(operator, str):\n            raise ValueError(\"Operator must be a string\")\n        if operator == \"+\":\n            return (left + right,)\n        if operator == \"-\":\n            return (left - right,)\n        if operator == \"*\":\n            return (left * right,)\n        if operator == \"/\":\n            return (left / right,)\n\n        raise ValueError(f\"Unsupported operator: {operator}\")\n</code></pre>"},{"location":"nodes/numbers/#floatoperator","title":"FloatOperator","text":"<p>Performs arithmetic operations on two floats</p>"},{"location":"nodes/numbers/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required left FLOAT 0 step: 0.01 required right FLOAT 0 step: 0.01 required operator"},{"location":"nodes/numbers/#returns_5","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class FloatOperator:\n    \"\"\"Performs arithmetic operations on two floats.\n\n    This class supports basic arithmetic operations (+, -, *, /) on two float inputs.\n\n    Methods:\n        execute(**kwargs): Returns the result of the arithmetic operation.\n\n    Raises:\n        ValueError: If the input values are not floats or if the operator is unsupported.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"left\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n                \"right\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01},\n                ),\n                \"operator\": ([\"+\", \"-\", \"*\", \"/\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"FLOAT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        left = kwargs.get(\"left\")\n        if not isinstance(left, float):\n            raise ValueError(\"Left must be a float\")\n        right = kwargs.get(\"right\")\n        if not isinstance(right, float):\n            raise ValueError(\"Right must be a float\")\n        operator = kwargs.get(\"operator\")\n        if not isinstance(operator, str):\n            raise ValueError(\"Operator must be a string\")\n        if operator == \"+\":\n            return (left + right,)\n        if operator == \"-\":\n            return (left - right,)\n        if operator == \"*\":\n            return (left * right,)\n        if operator == \"/\":\n            return (left / right,)\n\n        raise ValueError(f\"Unsupported operator: {operator}\")\n</code></pre>"},{"location":"nodes/numbers/#intminmax","title":"IntMinMax","text":"<p>Finds the minimum or maximum of two integers</p>"},{"location":"nodes/numbers/#inputs_6","title":"Inputs","text":"Group Name Type Default Extras required a INT 0 forceInput: True required b INT 0 forceInput: True required mode"},{"location":"nodes/numbers/#returns_6","title":"Returns","text":"Name Type int <code>INT</code> Pick the code in numbers.py <pre><code>class IntMinMax:\n    \"\"\"Finds the minimum or maximum of two integers.\n\n    This class returns either the minimum or maximum of two integer inputs based on the specified mode.\n\n    Methods:\n        execute(**kwargs): Returns the minimum or maximum integer.\n\n    Raises:\n        ValueError: If the input values are not integers or if the mode is unsupported.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"a\": (\"INT\", {\"default\": 0, \"forceInput\": True}),\n                \"b\": (\"INT\", {\"default\": 0, \"forceInput\": True}),\n                \"mode\": ([\"min\", \"max\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"INT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        a = kwargs.get(\"a\")\n        b = kwargs.get(\"b\")\n        if not isinstance(a, int):\n            raise ValueError(\"A must be an integer\")\n        if not isinstance(b, int):\n            raise ValueError(\"B must be an integer\")\n        mode = kwargs.get(\"mode\")\n        if not isinstance(mode, str):\n            raise ValueError(\"Mode must be a string\")\n        if mode == \"min\":\n            return (min(a, b),)\n        if mode == \"max\":\n            return (max(a, b),)\n        raise ValueError(f\"Unsupported mode: {mode}\")\n</code></pre>"},{"location":"nodes/numbers/#floatminmax","title":"FloatMinMax","text":"<p>Finds the minimum or maximum of two floats</p>"},{"location":"nodes/numbers/#inputs_7","title":"Inputs","text":"Group Name Type Default Extras required a FLOAT 0 forceInput: True required b FLOAT 0 forceInput: True required mode"},{"location":"nodes/numbers/#returns_7","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class FloatMinMax:\n    \"\"\"Finds the minimum or maximum of two floats.\n\n    This class returns either the minimum or maximum of two float inputs based on the specified mode.\n\n    Methods:\n        execute(**kwargs): Returns the minimum or maximum float.\n\n    Raises:\n        ValueError: If the input values are not floats or if the mode is unsupported.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"a\": (\"FLOAT\", {\"default\": 0, \"forceInput\": True}),\n                \"b\": (\"FLOAT\", {\"default\": 0, \"forceInput\": True}),\n                \"mode\": ([\"min\", \"max\"],),\n            }\n        }\n\n    RETURN_TYPES = (\"FLOAT\",)\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n        a = kwargs.get(\"a\")\n        b = kwargs.get(\"b\")\n        if not isinstance(a, float):\n            raise ValueError(\"A must be a float\")\n        if not isinstance(b, float):\n            raise ValueError(\"B must be a float\")\n        mode = kwargs.get(\"mode\")\n        if not isinstance(mode, str):\n            raise ValueError(\"Mode must be a string\")\n        if mode == \"min\":\n            return (min(a, b),)\n        if mode == \"max\":\n            return (max(a, b),)\n        raise ValueError(f\"Unsupported mode: {mode}\")\n</code></pre>"},{"location":"nodes/numbers/#randomnumber","title":"RandomNumber","text":"<p>Generates a random integer and its float representation</p>"},{"location":"nodes/numbers/#inputs_8","title":"Inputs","text":"Group Name Type Default Extras"},{"location":"nodes/numbers/#returns_8","title":"Returns","text":"Name Type int <code>INT</code> float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class RandomNumber:\n    \"\"\"Generates a random integer and its float representation.\n\n    This class generates a random integer within a specified range and provides its float representation.\n\n    Methods:\n        execute(): Returns a tuple containing the random integer and its float representation.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\"required\": {}}\n\n    RETURN_TYPES = (\n        \"INT\",\n        \"FLOAT\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    @staticmethod\n    def get_random():\n        result = random.randint(0, MAX_INT)\n        return (\n            result,\n            float(result),\n        )\n\n    def execute(self):\n        return RandomNumber.get_random()\n\n    @classmethod\n    def IS_CHANGED(cls):  # type: ignore\n        return RandomNumber.get_random()\n</code></pre>"},{"location":"nodes/numbers/#mathoperator","title":"MathOperator","text":"<p>Evaluates mathematical expressions using variables and operators</p>"},{"location":"nodes/numbers/#inputs_9","title":"Inputs","text":"Group Name Type Default Extras optional a FLOAT 0 step: 0.01 optional b FLOAT 0 step: 0.01 optional c FLOAT 0 step: 0.01 optional d FLOAT 0 step: 0.01 required value STRING multiline: True"},{"location":"nodes/numbers/#returns_9","title":"Returns","text":"Name Type int <code>INT</code> float <code>FLOAT</code> Pick the code in numbers.py <pre><code>class MathOperator:\n    \"\"\"Evaluates mathematical expressions using variables and operators.\n\n    This class evaluates mathematical expressions that can include variables (a, b, c, d) and a variety of operators.\n\n    Methods:\n        execute(**kwargs): Returns the result of the evaluated expression as both an integer and a float.\n\n    Raises:\n        ValueError: If the expression contains unsupported operations or invalid syntax.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"optional\": {\n                \"a\": (\"FLOAT\", {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01}),\n                \"b\": (\"FLOAT\", {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01}),\n                \"c\": (\"FLOAT\", {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01}),\n                \"d\": (\"FLOAT\", {\"default\": 0, \"min\": -MAX_FLOAT, \"max\": MAX_FLOAT, \"step\": 0.01}),\n            },\n            \"required\": {\n                \"value\": (\"STRING\", {\"multiline\": True, \"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\n        \"INT\",\n        \"FLOAT\",\n    )\n    FUNCTION = \"execute\"\n    CATEGORY = NUMBERS_CAT\n\n    def execute(self, **kwargs):\n\n        a = kwargs.get(\"a\") or 0.0\n        b = kwargs.get(\"b\") or 0.0\n        c = kwargs.get(\"c\") or 0.0\n        d = kwargs.get(\"d\") or 0.0\n        value = kwargs.get(\"value\") or \"\"\n        # trim value\n        value = value.strip()\n\n        def safe_xor(x, y):\n            if isinstance(x, float) or isinstance(y, float):\n                # Convert to integers if either operand is a float\n                return float(int(x) ^ int(y))\n            return op.xor(x, y)\n\n        operators = {\n            ast.Add: op.add,\n            ast.Sub: op.sub,\n            ast.Mult: op.mul,\n            ast.Div: op.truediv,\n            ast.FloorDiv: op.floordiv,\n            ast.Pow: op.pow,\n            ast.USub: op.neg,\n            ast.Mod: op.mod,\n            ast.Eq: op.eq,\n            ast.NotEq: op.ne,\n            ast.Lt: op.lt,\n            ast.LtE: op.le,\n            ast.Gt: op.gt,\n            ast.GtE: op.ge,\n            ast.And: lambda x, y: x and y,\n            ast.Or: lambda x, y: x or y,\n            ast.Not: op.not_,\n            ast.BitXor: safe_xor,  # Use the safe_xor function\n        }\n\n        op_functions = {\n            \"min\": min,\n            \"max\": max,\n            \"round\": round,\n            \"sum\": sum,\n            \"len\": len,\n        }\n\n        def eval_(node):\n            if isinstance(node, ast.Num):  # number\n                return node.n\n            if isinstance(node, ast.Name):  # variable\n                if node.id == \"a\":\n                    return a\n                if node.id == \"b\":\n                    return b\n                if node.id == \"c\":\n                    return c\n                if node.id == \"d\":\n                    return d\n            if isinstance(node, ast.BinOp):  # &lt;left&gt; &lt;operator&gt; &lt;right&gt;\n                return operators[type(node.op)](eval_(node.left), eval_(node.right))  # type: ignore\n            if isinstance(node, ast.UnaryOp):  # &lt;operator&gt; &lt;operand&gt; e.g., -1\n                return operators[type(node.op)](eval_(node.operand))  # type: ignore\n            if isinstance(node, ast.Compare):  # comparison operators\n                left = eval_(node.left)\n                for operator, comparator in zip(node.ops, node.comparators):\n                    if not operators[type(operator)](left, eval_(comparator)):  # type: ignore\n                        return 0\n                return 1\n            if isinstance(node, ast.BoolOp):  # boolean operators (And, Or)\n                values = [eval_(value) for value in node.values]\n                return operators[type(node.op)](*values)  # type: ignore\n            if isinstance(node, ast.Call):  # custom function\n                if node.func.id in op_functions:  # type: ignore\n                    args = [eval_(arg) for arg in node.args]\n                    return op_functions[node.func.id](*args)  # type: ignore\n            if isinstance(node, ast.Subscript):  # indexing or slicing\n                value = eval_(node.value)\n                if isinstance(node.slice, ast.Constant):\n                    return value[node.slice.value]\n                return 0\n            return 0\n\n        result = eval_(ast.parse(value, mode=\"eval\").body)\n\n        if math.isnan(result):  # type: ignore\n            result = 0.0\n\n        return (\n            round(result),  # type: ignore\n            result,\n        )\n</code></pre>"},{"location":"nodes/platform_io/","title":"Platform Io Nodes","text":""},{"location":"nodes/platform_io/#platforminputimage","title":"PlatformInputImage","text":"<p>Handles image input for the platform</p>"},{"location":"nodes/platform_io/#inputs","title":"Inputs","text":"Group Name Type Default Extras required title STRING Input Image required subtype required required BOOLEAN True required include_alpha BOOLEAN False required multiple BOOLEAN False required value STRING required metadata STRING {} multiline: True optional fallback Pick the code in platform_io.py <pre><code>class PlatformInputImage:\n    \"\"\"Handles image input for the platform.\n\n    This class processes image inputs, supporting both single and multiple images.\n    It can handle images from URLs or base64 strings and apply post-processing like alpha channel removal.\n\n    Methods:\n        execute(**kwargs): Processes the image input and returns a list of processed images.\n\n    Raises:\n        ValueError: If input values are not of the expected types or if no valid input is found.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Input Image\"}),\n                \"subtype\": ([\"image\", \"mask\"],),\n                \"required\": (\"BOOLEAN\", {\"default\": True}),\n                \"include_alpha\": (\"BOOLEAN\", {\"default\": False}),\n                \"multiple\": (\"BOOLEAN\", {\"default\": False}),\n                \"value\": (\"STRING\", {\"default\": \"\"}),\n                \"metadata\": (\"STRING\", {\"default\": \"{}\", \"multiline\": True}),\n            },\n            \"optional\": {\n                \"fallback\": (any_type,),\n            },\n        }\n\n    RETURN_TYPES = (any_type,)\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n    OUTPUT_IS_LIST = (True,)\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        def post_process(output: TensorImage, include_alpha: bool) -&gt; TensorImage:\n            if include_alpha is False and output.shape[1] == 4:\n                # get alpha\n                rgb = TensorImage(output[:, :3, :, :])\n                alpha = TensorImage(output[:, -1, :, :])\n                output, _ = cutout(rgb, alpha)\n            return output\n\n        value = kwargs.get(\"value\")\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        subtype = kwargs.get(\"subtype\")\n        if not isinstance(subtype, str):\n            raise ValueError(\"Subtype must be a string\")\n        include_alpha = kwargs.get(\"include_alpha\") or False\n        if not isinstance(include_alpha, bool):\n            raise ValueError(\"Include alpha must be a boolean\")\n        multiple = kwargs.get(\"multiple\") or False\n        if not isinstance(multiple, bool):\n            raise ValueError(\"Multiple must be a boolean\")\n        fallback = kwargs.get(\"fallback\")\n\n        if \",\" in value:\n            splited_value = value.split(\",\")\n            value = splited_value if multiple else splited_value[0]\n        else:\n            value = [value] if value != \"\" else []\n        outputs: list[TensorImage | torch.Tensor] = []\n        for i, _ in enumerate(value):\n            item = value[i]\n            if isinstance(item, str):\n                if item != \"\":\n                    if item.startswith(\"http\"):\n                        output = TensorImage.from_web(item)\n                    else:\n                        try:\n                            output = TensorImage.from_base64(item)\n                        except:\n                            raise ValueError(f\"Unsupported input format: {item}\")\n                    outputs.append(output)\n        if len(outputs) == 0:\n            if fallback is None:\n                raise ValueError(\"No input found\")\n            tensor_fallback = TensorImage.from_BWHC(fallback)\n            outputs.append(tensor_fallback)\n        for i, _ in enumerate(outputs):\n            output = outputs[i]\n            if isinstance(output, torch.Tensor):\n                output = TensorImage(output)\n            if subtype == \"mask\":\n                outputs[i] = output.get_grayscale().get_BWHC()\n            else:\n                if isinstance(output, TensorImage):\n                    outputs[i] = post_process(output, include_alpha).get_BWHC()\n        return (outputs,)\n</code></pre>"},{"location":"nodes/platform_io/#platforminputconnector","title":"PlatformInputConnector","text":"<p>Handles input from external connectors like Google Drive</p>"},{"location":"nodes/platform_io/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required title STRING Input Connector required subtype required required BOOLEAN True required override BOOLEAN False required token STRING required mime_type STRING image/png required value STRING required metadata STRING {} multiline: True"},{"location":"nodes/platform_io/#returns","title":"Returns","text":"Name Type file <code>FILE</code> Pick the code in platform_io.py <pre><code>class PlatformInputConnector:\n    \"\"\"Handles input from external connectors like Google Drive.\n\n    This class manages file downloads from external services using provided tokens and file IDs.\n\n    Methods:\n        execute(**kwargs): Downloads the specified file and returns the file data.\n\n    Raises:\n        ValueError: If input values are not of the expected types.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Input Connector\"}),\n                \"subtype\": ([\"google_drive\"],),\n                \"required\": (\"BOOLEAN\", {\"default\": True}),\n                \"override\": (\"BOOLEAN\", {\"default\": False}),\n                \"token\": (\"STRING\", {\"default\": \"\"}),\n                \"mime_type\": (\"STRING\", {\"default\": \"image/png\"}),\n                \"value\": (\"STRING\", {\"default\": \"\"}),\n                \"metadata\": (\"STRING\", {\"default\": \"{}\", \"multiline\": True}),\n            },\n        }\n\n    RETURN_TYPES = (\"FILE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n\n    def execute(\n        self,\n        **kwargs,\n    ):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        token = kwargs.get(\"token\")\n        if not isinstance(token, str):\n            raise ValueError(\"Token must be a string\")\n        mime_type = kwargs.get(\"mime_type\")\n        if not isinstance(mime_type, str):\n            raise ValueError(\"Mime type must be a string\")\n        override = kwargs.get(\"override\")\n        if not isinstance(override, bool):\n            raise ValueError(\"Override must be a boolean\")\n        connector = GoogleConnector(token=token)\n        input_folder = os.path.join(BASE_COMFY_DIR, \"input\")\n        data = connector.download(\n            file_id=value, mime_type=mime_type, output_path=input_folder, override=override\n        )\n        return (data,)\n</code></pre>"},{"location":"nodes/platform_io/#platforminputtext","title":"PlatformInputText","text":"<p>Handles text input for the platform</p>"},{"location":"nodes/platform_io/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required title STRING Input Text required subtype required required BOOLEAN True required value STRING multiline: True required metadata STRING {} multiline: True optional fallback STRING forceInput: True"},{"location":"nodes/platform_io/#returns_1","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in platform_io.py <pre><code>class PlatformInputText:\n    \"\"\"Handles text input for the platform.\n\n    This class processes text inputs, providing a fallback option if the input is empty.\n\n    Methods:\n        execute(**kwargs): Returns the input text or the fallback if the input is empty.\n\n    Raises:\n        ValueError: If input values are not of the expected types.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Input Text\"}),\n                \"subtype\": ([\"string\", \"positive_prompt\", \"negative_prompt\"],),\n                \"required\": (\"BOOLEAN\", {\"default\": True}),\n                \"value\": (\"STRING\", {\"multiline\": True, \"default\": \"\"}),\n                \"metadata\": (\"STRING\", {\"default\": \"{}\", \"multiline\": True}),\n            },\n            \"optional\": {\n                \"fallback\": (\"STRING\", {\"forceInput\": True}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n\n    def execute(self, **kwargs):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        fallback = kwargs.get(\"fallback\")\n        if not isinstance(fallback, str):\n            raise ValueError(\"Fallback must be a string\")\n        if value == \"\":\n            value = fallback or \"\"\n        return (value,)\n</code></pre>"},{"location":"nodes/platform_io/#platforminputnumber","title":"PlatformInputNumber","text":"<p>Handles numeric input for the platform</p>"},{"location":"nodes/platform_io/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required title STRING Input Number required subtype required required BOOLEAN True required value FLOAT 0 required metadata STRING {} multiline: True Pick the code in platform_io.py <pre><code>class PlatformInputNumber:\n    \"\"\"Handles numeric input for the platform.\n\n    This class processes numeric inputs, supporting both integers and floats.\n\n    Methods:\n        execute(**kwargs): Returns the input number, converting it to the specified subtype.\n\n    Raises:\n        ValueError: If input values are not of the expected types.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Input Number\"}),\n                \"subtype\": ([\"float\", \"int\"],),\n                \"required\": (\"BOOLEAN\", {\"default\": True}),\n                \"value\": (\"FLOAT\", {\"default\": 0}),\n                \"metadata\": (\"STRING\", {\"default\": \"{}\", \"multiline\": True}),\n            },\n        }\n\n    RETURN_TYPES = (any_type,)\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n\n    def execute(self, **kwargs):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, int) and not isinstance(value, float):\n            raise ValueError(\"Value must be a string\")\n        subtype = kwargs.get(\"subtype\")\n        if not isinstance(subtype, str):\n            raise ValueError(\"Subtype must be a string\")\n        if subtype == \"int\":\n            value = int(value)\n        else:\n            value = float(value)\n        return (value,)\n</code></pre>"},{"location":"nodes/platform_io/#platforminputboolean","title":"PlatformInputBoolean","text":"<p>Handles boolean input for the platform</p>"},{"location":"nodes/platform_io/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required title STRING Input Boolean required subtype required required BOOLEAN True required value BOOLEAN False required metadata STRING {} multiline: True"},{"location":"nodes/platform_io/#returns_2","title":"Returns","text":"Name Type boolean <code>BOOLEAN</code> Pick the code in platform_io.py <pre><code>class PlatformInputBoolean:\n    \"\"\"Handles boolean input for the platform.\n\n    This class processes boolean inputs.\n\n    Methods:\n        execute(**kwargs): Returns the input boolean value.\n\n    Raises:\n        ValueError: If input values are not of the expected types.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Input Boolean\"}),\n                \"subtype\": ([\"boolean\"],),\n                \"required\": (\"BOOLEAN\", {\"default\": True}),\n                \"value\": (\"BOOLEAN\", {\"default\": False}),\n                \"metadata\": (\"STRING\", {\"default\": \"{}\", \"multiline\": True}),\n            }\n        }\n\n    RETURN_TYPES = (\"BOOLEAN\",)\n    RETURN_NAMES = (\"boolean\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n\n    def execute(self, **kwargs):\n        value = kwargs.get(\"value\")\n        if not isinstance(value, bool):\n            raise ValueError(\"Value must be a boolean\")\n        return (value,)\n</code></pre>"},{"location":"nodes/platform_io/#platformoutput","title":"PlatformOutput","text":"<p>Handles output for the platform</p>"},{"location":"nodes/platform_io/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required title STRING Output Image required subtype required metadata STRING multiline: True required value hidden output_path STRING output Pick the code in platform_io.py <pre><code>class PlatformOutput:\n    \"\"\"Handles output for the platform.\n\n    This class manages the output of various data types, including images, numbers, and strings.\n    It supports saving images and generating thumbnails.\n\n    Methods:\n        execute(**kwargs): Processes and saves the output data, returning metadata about the saved files.\n\n    Raises:\n        ValueError: If input values are not of the expected types or if unsupported output types are provided.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"title\": (\"STRING\", {\"default\": \"Output Image\"}),\n                \"subtype\": ([\"image\", \"mask\", \"int\", \"float\", \"string\", \"dict\"],),\n                \"metadata\": (\"STRING\", {\"default\": \"\", \"multiline\": True}),\n                \"value\": (any_type,),\n            },\n            \"hidden\": {\n                \"output_path\": (\"STRING\", {\"default\": \"output\"}),\n            },\n        }\n\n    RETURN_TYPES = ()\n    OUTPUT_NODE = True\n    INPUT_IS_LIST = True\n    FUNCTION = \"execute\"\n    CATEGORY = PLATFORM_IO_CAT\n\n    def __save_outputs(\n        self, img, title: str, subtype: str, thumbnail_size: int, output_dir: str, metadata: str = \"\"\n    ) -&gt; dict | None:\n        current_time_str = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        file_name = f\"signature_{current_time_str}_{uuid7str()}.png\"\n        save_path = os.path.join(output_dir, file_name)\n        if os.path.exists(save_path):\n            file_name = f\"signature_{current_time_str}_{uuid7str()}_{uuid7str()}.png\"\n            save_path = os.path.join(output_dir, file_name)\n\n        output_img = TensorImage(img)\n\n        thumbnail_img = output_img.get_resized(thumbnail_size)\n        thumbnail_path = save_path.replace(\".png\", \"_thumbnail.jpeg\")\n        thumbnail_file_name = file_name.replace(\".png\", \"_thumbnail.jpeg\")\n        thumbnail_saved = thumbnail_img.save(thumbnail_path)\n\n        image_saved = output_img.save(save_path)\n\n        if image_saved and thumbnail_saved:\n            return {\n                \"title\": title,\n                \"type\": subtype,\n                \"metadata\": metadata,\n                \"value\": file_name,\n                \"thumbnail\": thumbnail_file_name if thumbnail_saved else None,\n            }\n\n        return None\n\n    def execute(self, **kwargs):\n        title_list = kwargs.get(\"title\")\n        if not isinstance(title_list, list):\n            raise ValueError(\"Title must be a list\")\n        metadata_list = kwargs.get(\"metadata\")\n        if not isinstance(metadata_list, list):\n            raise ValueError(\"Metadata must be a list\")\n        subtype_list = kwargs.get(\"subtype\")\n        if not isinstance(subtype_list, list):\n            raise ValueError(\"Subtype must be a list\")\n        output_path_list = kwargs.get(\"output_path\")\n        print(f\"output_path_list: {output_path_list} {type(output_path_list)}\")\n        if not isinstance(output_path_list, list):\n            output_path_list = [\"output\"] * len(title_list)\n        value_list = kwargs.get(\"value\")\n        if not isinstance(value_list, list):\n            raise ValueError(\"Value must be a list\")\n        main_subtype = subtype_list[0]\n        supported_types = [\"image\", \"mask\", \"int\", \"float\", \"string\", \"dict\"]\n        if main_subtype not in supported_types:\n            raise ValueError(f\"Unsupported output type: {main_subtype}\")\n\n        results = []\n        thumbnail_size = 1024\n        for idx, item in enumerate(value_list):\n            title = title_list[idx]\n            metadata = metadata_list[idx]\n            output_dir = os.path.join(BASE_COMFY_DIR, output_path_list[idx])\n            if isinstance(item, torch.Tensor):\n                if main_subtype in [\"image\", \"mask\"]:\n                    tensor_images = TensorImage.from_BWHC(item.to(\"cpu\"))\n                    for img in tensor_images:\n                        result = self.__save_outputs(\n                            img, title, main_subtype, thumbnail_size, output_dir, metadata\n                        )\n                        if result:\n                            results.append(result)\n                else:\n                    raise ValueError(f\"Unsupported output type: {type(item)}\")\n            else:\n                value_json = json.dumps(item) if main_subtype == \"dict\" else item\n                results.append(\n                    {\"title\": title, \"type\": main_subtype, \"metadata\": metadata, \"value\": value_json}\n                )\n        return {\"ui\": {\"signature_output\": results}}\n</code></pre>"},{"location":"nodes/primitives/","title":"Primitives Nodes","text":""},{"location":"nodes/primitives/#float","title":"Float","text":"<p>Represents a floating-point number input</p>"},{"location":"nodes/primitives/#inputs","title":"Inputs","text":"Group Name Type Default Extras required value FLOAT 0 max: 18446744073709551615, step: 0.01"},{"location":"nodes/primitives/#returns","title":"Returns","text":"Name Type float <code>FLOAT</code> Pick the code in primitives.py <pre><code>class Float:\n    \"\"\"Represents a floating-point number input.\n\n    This class provides a node for handling floating-point number inputs with\n    specified default, minimum, maximum, and step values.\n\n    Methods:\n        execute(value): Returns the input floating-point value as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\n                    \"FLOAT\",\n                    {\"default\": 0, \"min\": -18446744073709551615, \"max\": 18446744073709551615, \"step\": 0.01},\n                ),\n            },\n        }\n\n    RETURN_TYPES = (\"FLOAT\",)\n    RETURN_NAMES = (\"float\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PRIMITIVES_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/primitives/#int","title":"Int","text":"<p>Represents an integer input</p>"},{"location":"nodes/primitives/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required value INT 0 max: 18446744073709551615, step: 1"},{"location":"nodes/primitives/#returns_1","title":"Returns","text":"Name Type int <code>INT</code> Pick the code in primitives.py <pre><code>class Int:\n    \"\"\"Represents an integer input.\n\n    This class provides a node for handling integer inputs with specified default, minimum, maximum, and step values.\n\n    Methods:\n        execute(value): Returns the input integer value as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\n                    \"INT\",\n                    {\"default\": 0, \"min\": -18446744073709551615, \"max\": 18446744073709551615, \"step\": 1},\n                ),\n            },\n        }\n\n    RETURN_TYPES = (\"INT\",)\n    RETURN_NAMES = (\"int\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PRIMITIVES_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/primitives/#string","title":"String","text":"<p>Represents a single-line string input</p>"},{"location":"nodes/primitives/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required value STRING"},{"location":"nodes/primitives/#returns_2","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in primitives.py <pre><code>class String:\n    \"\"\"Represents a single-line string input.\n\n    This class provides a node for handling single-line string inputs with a specified default value.\n\n    Methods:\n        execute(value): Returns the input string value as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    RETURN_NAMES = (\"string\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PRIMITIVES_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/primitives/#stringmultiline","title":"StringMultiline","text":"<p>Represents a multi-line string input</p>"},{"location":"nodes/primitives/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required value STRING multiline: True"},{"location":"nodes/primitives/#returns_3","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in primitives.py <pre><code>class StringMultiline:\n    \"\"\"Represents a multi-line string input.\n\n    This class provides a node for handling multi-line string inputs with a specified default value.\n\n    Methods:\n        execute(value): Returns the input multi-line string value as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\"STRING\", {\"default\": \"\", \"multiline\": True}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    RETURN_NAMES = (\"string\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PRIMITIVES_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/primitives/#boolean","title":"Boolean","text":"<p>Represents a boolean input</p>"},{"location":"nodes/primitives/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required value BOOLEAN False"},{"location":"nodes/primitives/#returns_4","title":"Returns","text":"Name Type boolean <code>BOOLEAN</code> Pick the code in primitives.py <pre><code>class Boolean:\n    \"\"\"Represents a boolean input.\n\n    This class provides a node for handling boolean inputs with a specified default value.\n\n    Methods:\n        execute(value): Returns the input boolean value as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (\"BOOLEAN\", {\"default\": False}),\n            },\n        }\n\n    RETURN_TYPES = (\"BOOLEAN\",)\n    RETURN_NAMES = (\"boolean\",)\n    FUNCTION = \"execute\"\n    CATEGORY = PRIMITIVES_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/text/","title":"Text Nodes","text":""},{"location":"nodes/text/#textpreview","title":"TextPreview","text":"<p>Generates a preview of text inputs</p>"},{"location":"nodes/text/#inputs","title":"Inputs","text":"Group Name Type Default Extras required text"},{"location":"nodes/text/#returns","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextPreview:\n    \"\"\"Generates a preview of text inputs.\n\n    This class takes a list of text inputs and generates a single string preview.\n    If the input is a torch.Tensor, it includes the tensor's shape in the preview.\n\n    Returns:\n        dict: A dictionary containing the preview text under the 'ui' key and the result as a tuple.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"text\": (any_type,),\n            },\n        }\n\n    INPUT_IS_LIST = True\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    OUTPUT_NODE = True\n    OUTPUT_IS_LIST = (True,)\n\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\", [])\n        text_string = \"\"\n        for t in text:\n            if t is None:\n                continue\n            if text_string != \"\":\n                text_string += \"\\n\"\n            text_string += str(t.shape) if isinstance(t, torch.Tensor) else str(t)\n        return {\"ui\": {\"text\": [text_string]}, \"result\": (text_string,)}\n</code></pre>"},{"location":"nodes/text/#textcase","title":"TextCase","text":"<p>Changes the case of a given text</p>"},{"location":"nodes/text/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required text STRING forceInput: True required case"},{"location":"nodes/text/#returns_1","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextCase:\n    \"\"\"Changes the case of a given text.\n\n    This class provides functionality to convert text to lower, upper, capitalize, or title case.\n\n    Args:\n        text (str): The input text to be transformed.\n        case (str): The case transformation to apply ('lower', 'upper', 'capitalize', 'title').\n\n    Returns:\n        tuple: The transformed text.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"text\": (\"STRING\", {\"forceInput\": True}),\n                \"case\": ([\"lower\", \"upper\", \"capitalize\", \"title\"],),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\") or \"\"\n        case = kwargs.get(\"case\") or \"lower\"\n        result = text\n        if case == \"lower\":\n            result = text.lower()\n        if case == \"upper\":\n            result = text.upper()\n        if case == \"capitalize\":\n            result = text.capitalize()\n        if case == \"title\":\n            result = text.title()\n        return (result,)\n</code></pre>"},{"location":"nodes/text/#texttrim","title":"TextTrim","text":"<p>Trims whitespace from text</p>"},{"location":"nodes/text/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required text STRING forceInput: True required trim_type"},{"location":"nodes/text/#returns_2","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextTrim:\n    \"\"\"Trims whitespace from text.\n\n    This class trims whitespace from the left, right, or both sides of the input text.\n\n    Args:\n        text (str): The input text to be trimmed.\n        trim_type (str): The type of trim to apply ('both', 'left', 'right').\n\n    Returns:\n        tuple: The trimmed text.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"text\": (\"STRING\", {\"forceInput\": True}),\n                \"trim_type\": ([\"both\", \"left\", \"right\"],),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\") or \"\"\n        trim_type = kwargs.get(\"trim_type\") or \"both\"\n        if trim_type == \"both\":\n            return (text.strip(),)\n        if trim_type == \"left\":\n            return (text.lstrip(),)\n        if trim_type == \"right\":\n            return (text.rstrip(),)\n        return (text,)\n</code></pre>"},{"location":"nodes/text/#textsplit","title":"TextSplit","text":"<p>Splits text into a list based on a delimiter</p>"},{"location":"nodes/text/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required text STRING forceInput: True required delimiter STRING"},{"location":"nodes/text/#returns_3","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextSplit:\n    \"\"\"Splits text into a list based on a delimiter.\n\n    This class splits the input text into a list of strings using the specified delimiter.\n\n    Args:\n        text (str): The input text to be split.\n        delimiter (str): The delimiter to use for splitting the text.\n\n    Returns:\n        tuple: A list of split text segments.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"text\": (\"STRING\", {\"forceInput\": True}),\n                \"delimiter\": (\"STRING\", {\"default\": \" \"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n    OUTPUT_IS_LIST = (True,)\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\", \"\")\n        delimiter = kwargs.get(\"delimiter\", \" \")\n        return (text.split(delimiter),)\n</code></pre>"},{"location":"nodes/text/#textregexreplace","title":"TextRegexReplace","text":"<p>Performs regex-based text replacement</p>"},{"location":"nodes/text/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required text STRING forceInput: True required pattern STRING required replacement STRING"},{"location":"nodes/text/#returns_4","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextRegexReplace:\n    \"\"\"Performs regex-based text replacement.\n\n    This class uses regular expressions to find and replace patterns in the input text.\n\n    Args:\n        text (str): The input text to be processed.\n        pattern (str): The regex pattern to search for.\n        replacement (str): The string to replace the pattern with.\n\n    Returns:\n        tuple: The text after regex replacement.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"text\": (\"STRING\", {\"forceInput\": True}),\n                \"pattern\": (\"STRING\", {\"default\": \"\"}),\n                \"replacement\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\", \"\")\n        pattern = kwargs.get(\"pattern\", \"\")\n        replacement = kwargs.get(\"replacement\", \"\")\n        return (re.sub(pattern, replacement, text),)\n</code></pre>"},{"location":"nodes/text/#textfindreplace","title":"TextFindReplace","text":"<p>Finds and replaces text</p>"},{"location":"nodes/text/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required text STRING required find STRING required replace STRING"},{"location":"nodes/text/#returns_5","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextFindReplace:\n    \"\"\"Finds and replaces text.\n\n    This class finds a specified substring in the input text and replaces it with another substring.\n\n    Args:\n        text (str): The input text to be processed.\n        find (str): The substring to find.\n        replace (str): The substring to replace with.\n\n    Returns:\n        tuple: The text after find and replace.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"text\": (\"STRING\", {\"default\": \"\"}),\n                \"find\": (\"STRING\", {\"default\": \"\"}),\n                \"replace\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text = kwargs.get(\"text\") or \"\"\n        find = kwargs.get(\"find\") or \"\"\n        replace = kwargs.get(\"replace\") or \"\"\n        return (text.replace(find, replace),)\n</code></pre>"},{"location":"nodes/text/#textconcatenate","title":"TextConcatenate","text":"<p>Concatenates two text strings</p>"},{"location":"nodes/text/#inputs_6","title":"Inputs","text":"Group Name Type Default Extras required text1 STRING required text2 STRING"},{"location":"nodes/text/#returns_6","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in text.py <pre><code>class TextConcatenate:\n    \"\"\"Concatenates two text strings.\n\n    This class concatenates two input text strings into a single string.\n\n    Args:\n        text1 (str): The first text string.\n        text2 (str): The second text string.\n\n    Returns:\n        tuple: The concatenated text.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"text1\": (\"STRING\", {\"default\": \"\"}),\n                \"text2\": (\"STRING\", {\"default\": \"\"}),\n            },\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = TEXT_CAT\n\n    def execute(self, **kwargs):\n        text1 = kwargs.get(\"text1\", \"\")\n        text2 = kwargs.get(\"text2\", \"\")\n        return (text1 + text2,)\n</code></pre>"},{"location":"nodes/utils/","title":"Utils Nodes","text":""},{"location":"nodes/utils/#any2string","title":"Any2String","text":"<p>Converts any input value to its string representation</p>"},{"location":"nodes/utils/#inputs","title":"Inputs","text":"Group Name Type Default Extras required value"},{"location":"nodes/utils/#returns","title":"Returns","text":"Name Type string <code>STRING</code> Pick the code in utils.py <pre><code>class Any2String:\n    \"\"\"Converts any input value to its string representation.\n\n    A utility node that takes any input value and converts it to a string using Python's str() function.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (any_type,),\n            }\n        }\n\n    RETURN_TYPES = (\"STRING\",)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, value):\n        return (str(value),)\n</code></pre>"},{"location":"nodes/utils/#any2image","title":"Any2Image","text":"<p>Converts any inputs value to image format</p>"},{"location":"nodes/utils/#inputs_1","title":"Inputs","text":"Group Name Type Default Extras required value"},{"location":"nodes/utils/#returns_1","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in utils.py <pre><code>class Any2Image:\n    \"\"\"Converts any inputs value to image format.\n\n    A utility node that converts tensor inputs to image format. Currently only supports torch.Tensor inputs.\n\n    Raises:\n        ValueError: If the input value is not a torch.Tensor.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (any_type,),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, value):\n        if isinstance(value, torch.Tensor):\n            return (value,)\n        raise ValueError(f\"Unsupported type: {type(value)}\")\n</code></pre>"},{"location":"nodes/utils/#any2any","title":"Any2Any","text":"<p>Passes through any input value unchanged</p>"},{"location":"nodes/utils/#inputs_2","title":"Inputs","text":"Group Name Type Default Extras required value Pick the code in utils.py <pre><code>class Any2Any:\n    \"\"\"Passes through any input value unchanged.\n\n    A utility node that acts as a pass-through, returning the input value without modification.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"value\": (any_type,),\n            }\n        }\n\n    RETURN_TYPES = (any_type,)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, value):\n        return (value,)\n</code></pre>"},{"location":"nodes/utils/#rgb2hsv","title":"RGB2HSV","text":"<p>Converts RGB images to HSV color space</p>"},{"location":"nodes/utils/#inputs_3","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/utils/#returns_2","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in utils.py <pre><code>class RGB2HSV:\n    \"\"\"Converts RGB images to HSV color space.\n\n    A utility node that converts RGB format images to HSV (Hue, Saturation, Value) color space.\n    Expects input images in BWHC format.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, image: torch.Tensor):\n        image_tensor = TensorImage.from_BWHC(image)\n        output = rgb_to_hsv(image_tensor).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/utils/#rgbhls","title":"RGBHLS","text":"<p>Converts RGB images to HLS color space</p>"},{"location":"nodes/utils/#inputs_4","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/utils/#returns_3","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in utils.py <pre><code>class RGBHLS:\n    \"\"\"Converts RGB images to HLS color space.\n\n    A utility node that converts RGB format images to HLS (Hue, Lightness, Saturation) color space.\n    Expects input images in BWHC format.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, image: torch.Tensor):\n        image_tensor = TensorImage.from_BWHC(image)\n        output = rgb_to_hls(image_tensor).get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/utils/#rgba2rgb","title":"RGBA2RGB","text":"<p>Converts RGBA images to RGB format</p>"},{"location":"nodes/utils/#inputs_5","title":"Inputs","text":"Group Name Type Default Extras required image IMAGE"},{"location":"nodes/utils/#returns_4","title":"Returns","text":"Name Type image <code>IMAGE</code> Pick the code in utils.py <pre><code>class RGBA2RGB:\n    \"\"\"Converts RGBA images to RGB format.\n\n    A utility node that converts RGBA (Red, Green, Blue, Alpha) images to RGB format.\n    If the input image is already in RGB format, it will be passed through unchanged.\n    Expects input images in BWHC format.\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"image\": (\"IMAGE\",),\n            }\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n\n    def execute(self, image: torch.Tensor):\n        image_tensor = TensorImage.from_BWHC(image)\n        if image_tensor.shape[1] == 4:\n            image_tensor = rgba_to_rgb(image_tensor)\n        output = image_tensor.get_BWHC()\n        return (output,)\n</code></pre>"},{"location":"nodes/utils/#purgevram","title":"PurgeVRAM","text":"<p>Cleans up VRAM by purging caches and/or unloading models</p>"},{"location":"nodes/utils/#inputs_6","title":"Inputs","text":"Group Name Type Default Extras required anything required purge_cache BOOLEAN True required purge_models BOOLEAN True Pick the code in utils.py <pre><code>class PurgeVRAM:\n    \"\"\"Cleans up VRAM by purging caches and/or unloading models.\n\n    A utility node that helps manage VRAM usage by:\n    - Clearing Python garbage collector\n    - Emptying PyTorch CUDA cache\n    - Optionally unloading all models\n    - Optionally purging system cache\n\n    Args:\n        anything: Any input value (unused, allows connection in workflow)\n        purge_cache (bool): Whether to purge system and CUDA cache\n        purge_models (bool): Whether to unload all models from memory\n    \"\"\"\n\n    @classmethod\n    def INPUT_TYPES(cls):  # type: ignore\n        return {\n            \"required\": {\n                \"anything\": (any_type, {}),\n                \"purge_cache\": (\"BOOLEAN\", {\"default\": True}),\n                \"purge_models\": (\"BOOLEAN\", {\"default\": True}),\n            },\n            \"optional\": {},\n        }\n\n    RETURN_TYPES = ()\n    FUNCTION = \"execute\"\n    CATEGORY = UTILS_CAT\n    OUTPUT_NODE = True\n\n    def execute(self, anything, purge_cache, purge_models):\n\n        if purge_cache:\n\n            gc.collect()\n            if torch.cuda.is_available():\n                torch.cuda.empty_cache()\n                torch.cuda.ipc_collect()\n\n        if purge_models:\n            mm.unload_all_models()\n            mm.soft_empty_cache(True)\n        return (None,)\n</code></pre>"}]}